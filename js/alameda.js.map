{"version":3,"sources":["js/alameda.js"],"names":["requirejs","require","define","global","Promise","undef","commentReplace","match","multi","multiText","singlePrefix","hasProp","obj","prop","hasOwn","call","getOwn","eachProp","func","mixin","target","source","force","deepStringMixin","value","Array","isArray","RegExp","getGlobal","g","split","forEach","part","newContext","contextName","trimDots","ary","i","length","splice","normalize","name","baseName","applyMap","pkgMain","mapValue","nameParts","j","nameSegment","lastIndex","foundMap","foundI","foundStarMap","starI","baseParts","normalizedBaseParts","map","config","starMap","nodeIdCompat","jsSuffixRegExp","test","replace","charAt","slice","concat","join","outerLoop","pkgs","makeShimExports","fn","ret","init","apply","arguments","exports","takeQueue","anonId","id","args","shim","queue","unshift","shift","defined","waiting","deferreds","main","deps","exportsFn","makeRequire","relName","topLevel","req","callback","errback","alt","cfg","handlers","makeMap","Error","asyncResolve","then","isBrowser","document","navigator","nameToUrl","moduleName","ext","skipExt","paths","syms","parentModule","url","parentPath","bundleId","bundlesMap","urlRegExp","baseUrl","urlArgs","toUrl","moduleNamePlusExt","index","lastIndexOf","segment","isRelative","substring","specified","resolve","d","onResourceLoad","context","finished","reject","err","rejected","makeNormalize","defineModule","factoryCalled","factory","values","cjsModule","usingExports","requireDeferreds","indexOf","depFinished","val","this","depDefined","depCount","depending","depMax","makeDefer","promise","pr","getDefer","push","makeErrback","dynaId","errCount","requireModules","waitForDep","depMap","callDep","makeLoad","load","fromTextCalled","error","fromText","text","textAlt","n","plainId","p","exec","e","callPlugin","plugin","splitPrefix","prefix","breakCycle","traced","processed","depId","dep","check","notFinished","waitInterval","waitSeconds","expired","startTime","Date","getTime","loadCount","onError","checkingLater","setTimeout","delayedError","trackedErrors","bundles","mapCache","calledDefine","calledPlugin","urlFetched","importScripts","script","createElement","setAttribute","type","scriptType","charset","async","addEventListener","pathConfig","parentNode","removeChild","src","head","appendChild","newMap","newId","parts","result","cacheKey","module","uri","defaultErrback","toString","commentRegExp","cjsRequireRegExp","depName","undefined","objs","v","packages","pkgObj","location","currDirRegExp","contexts","topReq","dataMain","subPath","bootstrapConfig","Object","prototype","hasOwnProperty","eval","amd","jQuery","_","skipDataMain","querySelectorAll","getAttribute","pop"],"mappings":"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","file":"js/alameda.js","sourcesContent":["/**\n * @license alameda 1.0.0 Copyright jQuery Foundation and other contributors.\n * Released under MIT license, http://github.com/requirejs/alameda/LICENSE\n */\n// Going sloppy because loader plugin execs may depend on non-strict execution.\n/*jslint sloppy: true, nomen: true, regexp: true */\n/*global document, navigator, importScripts, Promise, setTimeout */\n\nvar requirejs, require, define;\n(function (global, Promise, undef) {\n  if (!Promise) {\n    throw new Error('No Promise implementation available');\n  }\n\n  var topReq, dataMain, src, subPath,\n    bootstrapConfig = requirejs || require,\n    hasOwn = Object.prototype.hasOwnProperty,\n    contexts = {},\n    queue = [],\n    currDirRegExp = /^\\.\\//,\n    urlRegExp = /^\\/|\\:|\\?|\\.js$/,\n    commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,\n    cjsRequireRegExp = /[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g,\n    jsSuffixRegExp = /\\.js$/,\n    slice = Array.prototype.slice;\n\n  if (typeof requirejs === 'function') {\n    return;\n  }\n\n  // Could match something like ')//comment', do not lose the prefix to comment.\n  function commentReplace(match, multi, multiText, singlePrefix) {\n    return singlePrefix || '';\n  }\n\n  function hasProp(obj, prop) {\n    return hasOwn.call(obj, prop);\n  }\n\n  function getOwn(obj, prop) {\n    return obj && hasProp(obj, prop) && obj[prop];\n  }\n\n  /**\n   * Cycles over properties in an object and calls a function for each\n   * property value. If the function returns a truthy value, then the\n   * iteration is stopped.\n   */\n  function eachProp(obj, func) {\n    var prop;\n    for (prop in obj) {\n      if (hasProp(obj, prop)) {\n        if (func(obj[prop], prop)) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Simple function to mix in properties from source into target,\n   * but only if target does not already have a property of the same name.\n   */\n  function mixin(target, source, force, deepStringMixin) {\n    if (source) {\n      eachProp(source, function (value, prop) {\n        if (force || !hasProp(target, prop)) {\n          if (deepStringMixin && typeof value === 'object' && value &&\n            !Array.isArray(value) && typeof value !== 'function' &&\n            !(value instanceof RegExp)) {\n\n            if (!target[prop]) {\n              target[prop] = {};\n            }\n            mixin(target[prop], value, force, deepStringMixin);\n          } else {\n            target[prop] = value;\n          }\n        }\n      });\n    }\n    return target;\n  }\n\n  // Allow getting a global that expressed in\n  // dot notation, like 'a.b.c'.\n  function getGlobal(value) {\n    if (!value) {\n      return value;\n    }\n    var g = global;\n    value.split('.').forEach(function (part) {\n      g = g[part];\n    });\n    return g;\n  }\n\n  function newContext(contextName) {\n    var req, main, makeMap, callDep, handlers, checkingLater, load, context,\n      defined = {},\n      waiting = {},\n      config = {\n        // Defaults. Do not set a default for map\n        // config to speed up normalize(), which\n        // will run faster if there is no default.\n        waitSeconds: 7,\n        baseUrl: './',\n        paths: {},\n        bundles: {},\n        pkgs: {},\n        shim: {},\n        config: {}\n      },\n      mapCache = {},\n      requireDeferreds = [],\n      deferreds = {},\n      calledDefine = {},\n      calledPlugin = {},\n      loadCount = 0,\n      startTime = (new Date()).getTime(),\n      errCount = 0,\n      trackedErrors = {},\n      urlFetched = {},\n      bundlesMap = {},\n      asyncResolve = Promise.resolve();\n\n    /**\n     * Trims the . and .. from an array of path segments.\n     * It will keep a leading path segment if a .. will become\n     * the first path segment, to help with module name lookups,\n     * which act like paths, but can be remapped. But the end result,\n     * all paths that use this function should look normalized.\n     * NOTE: this method MODIFIES the input array.\n     * @param {Array} ary the array of path segments.\n     */\n    function trimDots(ary) {\n      var i, part, length = ary.length;\n      for (i = 0; i < length; i++) {\n        part = ary[i];\n        if (part === '.') {\n          ary.splice(i, 1);\n          i -= 1;\n        } else if (part === '..') {\n          // If at the start, or previous value is still ..,\n          // keep them so that when converted to a path it may\n          // still work when converted to a path, even though\n          // as an ID it is less than ideal. In larger point\n          // releases, may be better to just kick out an error.\n          if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {\n            continue;\n          } else if (i > 0) {\n            ary.splice(i - 1, 2);\n            i -= 2;\n          }\n        }\n      }\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @param {Boolean} applyMap apply the map config to the value. Should\n     * only be done if this normalization is for a dependency ID.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName, applyMap) {\n      var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,\n        foundMap, foundI, foundStarMap, starI,\n        baseParts = baseName && baseName.split('/'),\n        normalizedBaseParts = baseParts,\n        map = config.map,\n        starMap = map && map['*'];\n\n\n      //Adjust any relative paths.\n      if (name) {\n        name = name.split('/');\n        lastIndex = name.length - 1;\n\n        // If wanting node ID compatibility, strip .js from end\n        // of IDs. Have to do this here, and not in nameToUrl\n        // because node allows either .js or non .js to map\n        // to same file.\n        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n          name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n        }\n\n        // Starts with a '.' so need the baseName\n        if (name[0].charAt(0) === '.' && baseParts) {\n          //Convert baseName to array, and lop off the last part,\n          //so that . matches that 'directory' and not name of the baseName's\n          //module. For instance, baseName of 'one/two/three', maps to\n          //'one/two/three.js', but we want the directory, 'one/two' for\n          //this normalization.\n          normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n          name = normalizedBaseParts.concat(name);\n        }\n\n        trimDots(name);\n        name = name.join('/');\n      }\n\n      // Apply map config if available.\n      if (applyMap && map && (baseParts || starMap)) {\n        nameParts = name.split('/');\n\n        outerLoop: for (i = nameParts.length; i > 0; i -= 1) {\n          nameSegment = nameParts.slice(0, i).join('/');\n\n          if (baseParts) {\n            // Find the longest baseName segment match in the config.\n            // So, do joins on the biggest to smallest lengths of baseParts.\n            for (j = baseParts.length; j > 0; j -= 1) {\n              mapValue = getOwn(map, baseParts.slice(0, j).join('/'));\n\n              // baseName segment has config, find if it has one for\n              // this name.\n              if (mapValue) {\n                mapValue = getOwn(mapValue, nameSegment);\n                if (mapValue) {\n                  // Match, update name to the new value.\n                  foundMap = mapValue;\n                  foundI = i;\n                  break outerLoop;\n                }\n              }\n            }\n          }\n\n          // Check for a star map match, but just hold on to it,\n          // if there is a shorter segment match later in a matching\n          // config, then favor over this star map.\n          if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {\n            foundStarMap = getOwn(starMap, nameSegment);\n            starI = i;\n          }\n        }\n\n        if (!foundMap && foundStarMap) {\n          foundMap = foundStarMap;\n          foundI = starI;\n        }\n\n        if (foundMap) {\n          nameParts.splice(0, foundI, foundMap);\n          name = nameParts.join('/');\n        }\n      }\n\n      // If the name points to a package's name, use\n      // the package main instead.\n      pkgMain = getOwn(config.pkgs, name);\n\n      return pkgMain ? pkgMain : name;\n    }\n\n    function makeShimExports(value) {\n      function fn() {\n        var ret;\n        if (value.init) {\n          ret = value.init.apply(global, arguments);\n        }\n        return ret || (value.exports && getGlobal(value.exports));\n      }\n      return fn;\n    }\n\n    function takeQueue(anonId) {\n      var i, id, args, shim;\n      for (i = 0; i < queue.length; i += 1) {\n        // Peek to see if anon\n        if (typeof queue[i][0] !== 'string') {\n          if (anonId) {\n            queue[i].unshift(anonId);\n            anonId = undef;\n          } else {\n            // Not our anon module, stop.\n            break;\n          }\n        }\n        args = queue.shift();\n        id = args[0];\n        i -= 1;\n\n        if (!hasProp(defined, id) && !hasProp(waiting, id)) {\n          if (hasProp(deferreds, id)) {\n            main.apply(undef, args);\n          } else {\n            waiting[id] = args;\n          }\n        }\n      }\n\n      // if get to the end and still have anonId, then could be\n      // a shimmed dependency.\n      if (anonId) {\n        shim = getOwn(config.shim, anonId) || {};\n        main(anonId, shim.deps || [], shim.exportsFn);\n      }\n    }\n\n    function makeRequire(relName, topLevel) {\n      var req = function (deps, callback, errback, alt) {\n        var name, cfg;\n\n        if (topLevel) {\n          takeQueue();\n        }\n\n        if (typeof deps === \"string\") {\n          if (handlers[deps]) {\n            return handlers[deps](relName);\n          }\n          // Just return the module wanted. In this scenario, the\n          // deps arg is the module name, and second arg (if passed)\n          // is just the relName.\n          // Normalize module name, if it contains . or ..\n          name = makeMap(deps, relName, true).id;\n          if (!hasProp(defined, name)) {\n            throw new Error('Not loaded: ' + name);\n          }\n          return defined[name];\n        } else if (deps && !Array.isArray(deps)) {\n          // deps is a config object, not an array.\n          cfg = deps;\n          deps = undef;\n\n          if (Array.isArray(callback)) {\n            // callback is an array, which means it is a dependency list.\n            // Adjust args if there are dependencies\n            deps = callback;\n            callback = errback;\n            errback = alt;\n          }\n\n          if (topLevel) {\n            // Could be a new context, so call returned require\n            return req.config(cfg)(deps, callback, errback);\n          }\n        }\n\n        // Support require(['a'])\n        callback = callback || function () {\n          // In case used later as a promise then value, return the\n          // arguments as an array.\n          return slice.call(arguments, 0);\n        };\n\n        // Complete async to maintain expected execution semantics.\n        return asyncResolve.then(function () {\n          // Grab any modules that were defined after a require call.\n          takeQueue();\n\n          return main(undef, deps || [], callback, errback, relName);\n        });\n      };\n\n      req.isBrowser = typeof document !== 'undefined' &&\n        typeof navigator !== 'undefined';\n\n      req.nameToUrl = function (moduleName, ext, skipExt) {\n        var paths, syms, i, parentModule, url,\n          parentPath, bundleId,\n          pkgMain = getOwn(config.pkgs, moduleName);\n\n        if (pkgMain) {\n          moduleName = pkgMain;\n        }\n\n        bundleId = getOwn(bundlesMap, moduleName);\n\n        if (bundleId) {\n          return req.nameToUrl(bundleId, ext, skipExt);\n        }\n\n        // If a colon is in the URL, it indicates a protocol is used and it is\n        // just an URL to a file, or if it starts with a slash, contains a query\n        // arg (i.e. ?) or ends with .js, then assume the user meant to use an\n        // url and not a module id. The slash is important for protocol-less\n        // URLs as well as full paths.\n        if (urlRegExp.test(moduleName)) {\n          // Just a plain path, not module name lookup, so just return it.\n          // Add extension if it is included. This is a bit wonky, only non-.js\n          // things pass an extension, this method probably needs to be\n          // reworked.\n          url = moduleName + (ext || '');\n        } else {\n          // A module that needs to be converted to a path.\n          paths = config.paths;\n\n          syms = moduleName.split('/');\n          // For each module name segment, see if there is a path\n          // registered for it. Start with most specific name\n          // and work up from it.\n          for (i = syms.length; i > 0; i -= 1) {\n            parentModule = syms.slice(0, i).join('/');\n\n            parentPath = getOwn(paths, parentModule);\n            if (parentPath) {\n              // If an array, it means there are a few choices,\n              // Choose the one that is desired\n              if (Array.isArray(parentPath)) {\n                parentPath = parentPath[0];\n              }\n              syms.splice(0, i, parentPath);\n              break;\n            }\n          }\n\n          // Join the path parts together, then figure out if baseUrl is needed.\n          url = syms.join('/');\n          url += (ext || (/^data\\:|^blob\\:|\\?/.test(url) || skipExt ? '' : '.js'));\n          url = (url.charAt(0) === '/' ||\n                url.match(/^[\\w\\+\\.\\-]+:/) ? '' : config.baseUrl) + url;\n        }\n\n        return config.urlArgs && !/^blob\\:/.test(url) ?\n               url + config.urlArgs(moduleName, url) : url;\n      };\n\n      /**\n       * Converts a module name + .extension into an URL path.\n       * *Requires* the use of a module name. It does not support using\n       * plain URLs like nameToUrl.\n       */\n      req.toUrl = function (moduleNamePlusExt) {\n        var ext,\n          index = moduleNamePlusExt.lastIndexOf('.'),\n          segment = moduleNamePlusExt.split('/')[0],\n          isRelative = segment === '.' || segment === '..';\n\n        // Have a file extension alias, and it is not the\n        // dots from a relative path.\n        if (index !== -1 && (!isRelative || index > 1)) {\n          ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\n          moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\n        }\n\n        return req.nameToUrl(normalize(moduleNamePlusExt, relName), ext, true);\n      };\n\n      req.defined = function (id) {\n        return hasProp(defined, makeMap(id, relName, true).id);\n      };\n\n      req.specified = function (id) {\n        id = makeMap(id, relName, true).id;\n        return hasProp(defined, id) || hasProp(deferreds, id);\n      };\n\n      return req;\n    }\n\n    function resolve(name, d, value) {\n      if (name) {\n        defined[name] = value;\n        if (requirejs.onResourceLoad) {\n          requirejs.onResourceLoad(context, d.map, d.deps);\n        }\n      }\n      d.finished = true;\n      d.resolve(value);\n    }\n\n    function reject(d, err) {\n      d.finished = true;\n      d.rejected = true;\n      d.reject(err);\n    }\n\n    function makeNormalize(relName) {\n      return function (name) {\n        return normalize(name, relName, true);\n      };\n    }\n\n    function defineModule(d) {\n      d.factoryCalled = true;\n\n      var ret,\n        name = d.map.id;\n\n      try {\n         ret = d.factory.apply(defined[name], d.values);\n      } catch(err) {\n         return reject(d, err);\n      }\n\n      if (name) {\n        // Favor return value over exports. If node/cjs in play,\n        // then will not have a return value anyway. Favor\n        // module.exports assignment over exports object.\n        if (ret === undef) {\n          if (d.cjsModule) {\n            ret = d.cjsModule.exports;\n          } else if (d.usingExports) {\n            ret = defined[name];\n          }\n        }\n      } else {\n        // Remove the require deferred from the list to\n        // make cycle searching faster. Do not need to track\n        // it anymore either.\n        requireDeferreds.splice(requireDeferreds.indexOf(d), 1);\n      }\n      resolve(name, d, ret);\n    }\n\n    // This method is attached to every module deferred,\n    // so the \"this\" in here is the module deferred object.\n    function depFinished(val, i) {\n      if (!this.rejected && !this.depDefined[i]) {\n        this.depDefined[i] = true;\n        this.depCount += 1;\n        this.values[i] = val;\n        if (!this.depending && this.depCount === this.depMax) {\n          defineModule(this);\n        }\n      }\n    }\n\n    function makeDefer(name) {\n      var d = {};\n      d.promise = new Promise(function (resolve, reject) {\n        d.resolve = resolve;\n        d.reject = function(err) {\n          if (!name) {\n          requireDeferreds.splice(requireDeferreds.indexOf(d), 1);\n          }\n          reject(err);\n        };\n      });\n      d.map = name ? makeMap(name, null, true) : {};\n      d.depCount = 0;\n      d.depMax = 0;\n      d.values = [];\n      d.depDefined = [];\n      d.depFinished = depFinished;\n      if (d.map.pr) {\n        // Plugin resource ID, implicitly\n        // depends on plugin. Track it in deps\n        // so cycle breaking can work\n        d.deps = [makeMap(d.map.pr)];\n      }\n      return d;\n    }\n\n    function getDefer(name) {\n      var d;\n      if (name) {\n        d = hasProp(deferreds, name) && deferreds[name];\n        if (!d) {\n          d = deferreds[name] = makeDefer(name);\n        }\n      } else {\n        d = makeDefer();\n        requireDeferreds.push(d);\n      }\n      return d;\n    }\n\n    function makeErrback(d, name) {\n      return function (err) {\n        if (!d.rejected) {\n          if (!err.dynaId) {\n            err.dynaId = 'id' + (errCount += 1);\n            err.requireModules = [name];\n          }\n          reject(d, err);\n        }\n      };\n    }\n\n    function waitForDep(depMap, relName, d, i) {\n      d.depMax += 1;\n\n      // Do the fail at the end to catch errors\n      // in the then callback execution.\n      callDep(depMap, relName).then(function (val) {\n        d.depFinished(val, i);\n      }, makeErrback(d, depMap.id)).catch(makeErrback(d, d.map.id));\n    }\n\n    function makeLoad(id) {\n      var fromTextCalled;\n      function load(value) {\n        // Protect against older plugins that call load after\n        // calling load.fromText\n        if (!fromTextCalled) {\n          resolve(id, getDefer(id), value);\n        }\n      }\n\n      load.error = function (err) {\n        getDefer(id).reject(err);\n      };\n\n      load.fromText = function (text, textAlt) {\n        /*jslint evil: true */\n        var d = getDefer(id),\n          map = makeMap(makeMap(id).n),\n           plainId = map.id;\n\n        fromTextCalled = true;\n\n        // Set up the factory just to be a return of the value from\n        // plainId.\n        d.factory = function (p, val) {\n          return val;\n        };\n\n        // As of requirejs 2.1.0, support just passing the text, to reinforce\n        // fromText only being called once per resource. Still\n        // support old style of passing moduleName but discard\n        // that moduleName in favor of the internal ref.\n        if (textAlt) {\n          text = textAlt;\n        }\n\n        // Transfer any config to this other module.\n        if (hasProp(config.config, id)) {\n          config.config[plainId] = config.config[id];\n        }\n\n        try {\n          req.exec(text);\n        } catch (e) {\n          reject(d, new Error('fromText eval for ' + plainId +\n                  ' failed: ' + e));\n        }\n\n        // Execute any waiting define created by the plainId\n        takeQueue(plainId);\n\n        // Mark this as a dependency for the plugin\n        // resource\n        d.deps = [map];\n        waitForDep(map, null, d, d.deps.length);\n      };\n\n      return load;\n    }\n\n    load = typeof importScripts === 'function' ?\n        function (map) {\n          var url = map.url;\n          if (urlFetched[url]) {\n            return;\n          }\n          urlFetched[url] = true;\n\n          // Ask for the deferred so loading is triggered.\n          // Do this before loading, since loading is sync.\n          getDefer(map.id);\n          importScripts(url);\n          takeQueue(map.id);\n        } :\n        function (map) {\n          var script,\n            id = map.id,\n            url = map.url;\n\n          if (urlFetched[url]) {\n            return;\n          }\n          urlFetched[url] = true;\n\n          script = document.createElement('script');\n          script.setAttribute('data-requiremodule', id);\n          script.type = config.scriptType || 'text/javascript';\n          script.charset = 'utf-8';\n          script.async = true;\n\n          loadCount += 1;\n\n          script.addEventListener('load', function () {\n            loadCount -= 1;\n            takeQueue(id);\n          }, false);\n          script.addEventListener('error', function () {\n            loadCount -= 1;\n            var err,\n              pathConfig = getOwn(config.paths, id),\n              d = getOwn(deferreds, id);\n            if (pathConfig && Array.isArray(pathConfig) &&\n                pathConfig.length > 1) {\n              script.parentNode.removeChild(script);\n              // Pop off the first array value, since it failed, and\n              // retry\n              pathConfig.shift();\n              d.map = makeMap(id);\n              load(d.map);\n            } else {\n              err = new Error('Load failed: ' + id + ': ' + script.src);\n              err.requireModules = [id];\n              getDefer(id).reject(err);\n            }\n          }, false);\n\n          script.src = url;\n\n          document.head.appendChild(script);\n        };\n\n    function callPlugin(plugin, map, relName) {\n      plugin.load(map.n, makeRequire(relName), makeLoad(map.id), config);\n    }\n\n    callDep = function (map, relName) {\n      var args, bundleId,\n        name = map.id,\n        shim = config.shim[name];\n\n      if (hasProp(waiting, name)) {\n        args = waiting[name];\n        delete waiting[name];\n        main.apply(undef, args);\n      } else if (!hasProp(deferreds, name)) {\n        if (map.pr) {\n          // If a bundles config, then just load that file instead to\n          // resolve the plugin, as it is built into that bundle.\n          if ((bundleId = getOwn(bundlesMap, name))) {\n            map.url = req.nameToUrl(bundleId);\n            load(map);\n          } else {\n            return callDep(makeMap(map.pr)).then(function (plugin) {\n              // Redo map now that plugin is known to be loaded\n              var newMap = makeMap(name, relName, true),\n                newId = newMap.id,\n                shim = getOwn(config.shim, newId);\n\n              // Make sure to only call load once per resource. Many\n              // calls could have been queued waiting for plugin to load.\n              if (!hasProp(calledPlugin, newId)) {\n                calledPlugin[newId] = true;\n                if (shim && shim.deps) {\n                  req(shim.deps, function () {\n                    callPlugin(plugin, newMap, relName);\n                  });\n                } else {\n                  callPlugin(plugin, newMap, relName);\n                }\n              }\n              return getDefer(newId).promise;\n            });\n          }\n        } else if (shim && shim.deps) {\n          req(shim.deps, function () {\n            load(map);\n          });\n        } else {\n          load(map);\n        }\n      }\n\n      return getDefer(name).promise;\n    };\n\n    // Turns a plugin!resource to [plugin, resource]\n    // with the plugin being undefined if the name\n    // did not have a plugin prefix.\n    function splitPrefix(name) {\n      var prefix,\n        index = name ? name.indexOf('!') : -1;\n      if (index > -1) {\n        prefix = name.substring(0, index);\n        name = name.substring(index + 1, name.length);\n      }\n      return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName, applyMap) {\n      if (typeof name !== 'string') {\n        return name;\n      }\n\n      var plugin, url, parts, prefix, result,\n        cacheKey = name + ' & ' + (relName || '') + ' & ' + !!applyMap;\n\n      parts = splitPrefix(name);\n      prefix = parts[0];\n      name = parts[1];\n\n      if (!prefix && hasProp(mapCache, cacheKey)) {\n        return mapCache[cacheKey];\n      }\n\n      if (prefix) {\n        prefix = normalize(prefix, relName, applyMap);\n        plugin = hasProp(defined, prefix) && defined[prefix];\n      }\n\n      // Normalize according\n      if (prefix) {\n        if (plugin && plugin.normalize) {\n          name = plugin.normalize(name, makeNormalize(relName));\n        } else {\n          // If nested plugin references, then do not try to\n          // normalize, as it will not normalize correctly. This\n          // places a restriction on resourceIds, and the longer\n          // term solution is not to normalize until plugins are\n          // loaded and all normalizations to allow for async\n          // loading of a loader plugin. But for now, fixes the\n          // common uses. Details in requirejs#1131\n          name = name.indexOf('!') === -1 ?\n                   normalize(name, relName, applyMap) :\n                   name;\n        }\n      } else {\n        name = normalize(name, relName, applyMap);\n        parts = splitPrefix(name);\n        prefix = parts[0];\n        name = parts[1];\n\n        url = req.nameToUrl(name);\n      }\n\n      // Using ridiculous property names for space reasons\n      result = {\n        id: prefix ? prefix + '!' + name : name, // fullName\n        n: name,\n        pr: prefix,\n        url: url\n      };\n\n      if (!prefix) {\n        mapCache[cacheKey] = result;\n      }\n\n      return result;\n    };\n\n    handlers = {\n      require: function (name) {\n        return makeRequire(name);\n      },\n      exports: function (name) {\n        var e = defined[name];\n        if (typeof e !== 'undefined') {\n          return e;\n        } else {\n          return (defined[name] = {});\n        }\n      },\n      module: function (name) {\n        return {\n          id: name,\n          uri: '',\n          exports: handlers.exports(name),\n          config: function () {\n            return getOwn(config.config, name) || {};\n          }\n        };\n      }\n    };\n\n    function breakCycle(d, traced, processed) {\n      var id = d.map.id;\n\n      traced[id] = true;\n      if (!d.finished && d.deps) {\n        d.deps.forEach(function (depMap) {\n          var depId = depMap.id,\n            dep = !hasProp(handlers, depId) && getDefer(depId);\n\n          // Only force things that have not completed\n          // being defined, so still in the registry,\n          // and only if it has not been matched up\n          // in the module already.\n          if (dep && !dep.finished && !processed[depId]) {\n            if (hasProp(traced, depId)) {\n              d.deps.forEach(function (depMap, i) {\n                if (depMap.id === depId) {\n                  d.depFinished(defined[depId], i);\n                }\n              });\n            } else {\n              breakCycle(dep, traced, processed);\n            }\n          }\n        });\n      }\n      processed[id] = true;\n    }\n\n    function check(d) {\n      var err,\n        notFinished = [],\n        waitInterval = config.waitSeconds * 1000,\n        // It is possible to disable the wait interval by using waitSeconds 0.\n        expired = waitInterval &&\n                  (startTime + waitInterval) < (new Date()).getTime();\n\n    if (loadCount === 0) {\n        // If passed in a deferred, it is for a specific require call.\n        // Could be a sync case that needs resolution right away.\n        // Otherwise, if no deferred, means it was the last ditch\n        // timeout-based check, so check all waiting require deferreds.\n        if (d) {\n          if (!d.finished) {\n            breakCycle(d, {}, {});\n          }\n        } else if (requireDeferreds.length) {\n          requireDeferreds.forEach(function (d) {\n            breakCycle(d, {}, {});\n          });\n        }\n      }\n\n      // If still waiting on loads, and the waiting load is something\n      // other than a plugin resource, or there are still outstanding\n      // scripts, then just try back later.\n      if (expired) {\n        // If wait time expired, throw error of unloaded modules.\n        eachProp(deferreds, function (d) {\n          if (!d.finished) {\n            notFinished.push(d.map.id);\n          }\n        });\n        err = new Error('Timeout for modules: ' + notFinished);\n        err.requireModules = notFinished;\n        req.onError(err);\n      } else if (loadCount || requireDeferreds.length) {\n        // Something is still waiting to load. Wait for it, but only\n        // if a later check is not already scheduled. Using setTimeout\n        // because want other things in the event loop to happen,\n        // to help in dependency resolution, and this is really a\n        // last ditch check, mostly for detecting timeouts (cycles\n        // should come through the main() use of check()), so it can\n        // wait a bit before doing the final check.\n        if (!checkingLater) {\n          checkingLater = true;\n          setTimeout(function () {\n            checkingLater = false;\n            check();\n          }, 70);\n        }\n      }\n    }\n\n    // Used to break out of the promise try/catch chains.\n    function delayedError(e) {\n      setTimeout(function () {\n        if (!e.dynaId || !trackedErrors[e.dynaId]) {\n          trackedErrors[e.dynaId] = true;\n          req.onError(e);\n        }\n      });\n      return e;\n    }\n\n    main = function (name, deps, factory, errback, relName) {\n      // Only allow main calling once per module.\n      if (name && hasProp(calledDefine, name)) {\n        return;\n      }\n      calledDefine[name] = true;\n\n      var d = getDefer(name);\n\n      // This module may not have dependencies\n      if (deps && !Array.isArray(deps)) {\n        // deps is not an array, so probably means\n        // an object literal or factory function for\n        // the value. Adjust args.\n        factory = deps;\n        deps = [];\n      }\n\n      if (!errback) {\n        if (hasProp(config, 'defaultErrback')) {\n          if (config.defaultErrback) {\n            errback = config.defaultErrback;\n          }\n        } else {\n          errback = delayedError;\n        }\n      }\n\n      if (errback) {\n         d.promise.catch(errback);\n      }\n\n      // Use name if no relName\n      relName = relName || name;\n\n      // Call the factory to define the module, if necessary.\n      if (typeof factory === 'function') {\n\n        if (!deps.length && factory.length) {\n          // Remove comments from the callback string,\n          // look for require calls, and pull them into the dependencies,\n          // but only if there are function args.\n          factory\n            .toString()\n            .replace(commentRegExp, commentReplace)\n            .replace(cjsRequireRegExp, function (match, dep) {\n              deps.push(dep);\n            });\n\n          // May be a CommonJS thing even without require calls, but still\n          // could use exports, and module. Avoid doing exports and module\n          // work though if it just needs require.\n          // REQUIRES the function to expect the CommonJS variables in the\n          // order listed below.\n          deps = (factory.length === 1 ?\n              ['require'] :\n              ['require', 'exports', 'module']).concat(deps);\n        }\n\n        // Save info for use later.\n        d.factory = factory;\n        d.deps = deps;\n\n        d.depending = true;\n        deps.forEach(function (depName, i) {\n          var depMap;\n          deps[i] = depMap = makeMap(depName, relName, true);\n          depName = depMap.id;\n\n          // Fast path CommonJS standard dependencies.\n          if (depName === \"require\") {\n            d.values[i] = handlers.require(name);\n          } else if (depName === \"exports\") {\n            // CommonJS module spec 1.1\n            d.values[i] = handlers.exports(name);\n            d.usingExports = true;\n          } else if (depName === \"module\") {\n            // CommonJS module spec 1.1\n            d.values[i] = d.cjsModule = handlers.module(name);\n          } else if (depName === undefined) {\n            d.values[i] = undefined;\n          } else {\n            waitForDep(depMap, relName, d, i);\n          }\n        });\n        d.depending = false;\n\n        // Some modules just depend on the require, exports, modules, so\n        // trigger their definition here if so.\n        if (d.depCount === d.depMax) {\n          defineModule(d);\n        }\n      } else if (name) {\n        // May just be an object definition for the module. Only\n        // worry about defining if have a module name.\n        resolve(name, d, factory);\n      }\n\n      startTime = (new Date()).getTime();\n\n      if (!name) {\n        check(d);\n      }\n\n      return d.promise;\n    };\n\n    req = makeRequire(null, true);\n\n    /*\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n      if (cfg.context && cfg.context !== contextName) {\n        return newContext(cfg.context).config(cfg);\n      }\n\n      // Since config changed, mapCache may not be valid any more.\n      mapCache = {};\n\n      // Make sure the baseUrl ends in a slash.\n      if (cfg.baseUrl) {\n        if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {\n          cfg.baseUrl += '/';\n        }\n      }\n\n      // Convert old style urlArgs string to a function.\n      if (typeof cfg.urlArgs === 'string') {\n        var urlArgs = cfg.urlArgs;\n        cfg.urlArgs = function(id, url) {\n          return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;\n        };\n      }\n\n      // Save off the paths and packages since they require special processing,\n      // they are additive.\n      var shim = config.shim,\n        objs = {\n          paths: true,\n          bundles: true,\n          config: true,\n          map: true\n        };\n\n      eachProp(cfg, function (value, prop) {\n        if (objs[prop]) {\n          if (!config[prop]) {\n            config[prop] = {};\n          }\n          mixin(config[prop], value, true, true);\n        } else {\n          config[prop] = value;\n        }\n      });\n\n      // Reverse map the bundles\n      if (cfg.bundles) {\n        eachProp(cfg.bundles, function (value, prop) {\n          value.forEach(function (v) {\n            if (v !== prop) {\n              bundlesMap[v] = prop;\n            }\n          });\n        });\n      }\n\n      // Merge shim\n      if (cfg.shim) {\n        eachProp(cfg.shim, function (value, id) {\n          // Normalize the structure\n          if (Array.isArray(value)) {\n            value = {\n              deps: value\n            };\n          }\n          if ((value.exports || value.init) && !value.exportsFn) {\n            value.exportsFn = makeShimExports(value);\n          }\n          shim[id] = value;\n        });\n        config.shim = shim;\n      }\n\n      // Adjust packages if necessary.\n      if (cfg.packages) {\n        cfg.packages.forEach(function (pkgObj) {\n          var location, name;\n\n          pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;\n\n          name = pkgObj.name;\n          location = pkgObj.location;\n          if (location) {\n            config.paths[name] = pkgObj.location;\n          }\n\n          // Save pointer to main module ID for pkg name.\n          // Remove leading dot in main, so main paths are normalized,\n          // and remove any trailing .js, since different package\n          // envs have different conventions: some use a module name,\n          // some use a file name.\n          config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')\n                 .replace(currDirRegExp, '')\n                 .replace(jsSuffixRegExp, '');\n        });\n      }\n\n      // If a deps array or a config callback is specified, then call\n      // require with those args. This is useful when require is defined as a\n      // config object before require.js is loaded.\n      if (cfg.deps || cfg.callback) {\n        req(cfg.deps, cfg.callback);\n      }\n\n      return req;\n    };\n\n    req.onError = function (err) {\n      throw err;\n    };\n\n    context = {\n      id: contextName,\n      defined: defined,\n      waiting: waiting,\n      config: config,\n      deferreds: deferreds\n    };\n\n    contexts[contextName] = context;\n\n    return req;\n  }\n\n  requirejs = topReq = newContext('_');\n\n  if (typeof require !== 'function') {\n    require = topReq;\n  }\n\n  /**\n   * Executes the text. Normally just uses eval, but can be modified\n   * to use a better, environment-specific call. Only used for transpiling\n   * loader plugins, not for plain JS modules.\n   * @param {String} text the text to execute/evaluate.\n   */\n  topReq.exec = function (text) {\n    /*jslint evil: true */\n    return eval(text);\n  };\n\n  topReq.contexts = contexts;\n\n  define = function () {\n    queue.push(slice.call(arguments, 0));\n  };\n\n  define.amd = {\n    jQuery: true\n  };\n\n  if (bootstrapConfig) {\n    topReq.config(bootstrapConfig);\n  }\n\n  // data-main support.\n  if (topReq.isBrowser && !contexts._.config.skipDataMain) {\n    dataMain = document.querySelectorAll('script[data-main]')[0];\n    dataMain = dataMain && dataMain.getAttribute('data-main');\n    if (dataMain) {\n      // Strip off any trailing .js since dataMain is now\n      // like a module name.\n      dataMain = dataMain.replace(jsSuffixRegExp, '');\n\n      // Set final baseUrl if there is not already an explicit one,\n      // but only do so if the data-main value is not a loader plugin\n      // module ID.\n      if ((!bootstrapConfig || !bootstrapConfig.baseUrl) &&\n          dataMain.indexOf('!') === -1) {\n        // Pull off the directory of data-main for use as the\n        // baseUrl.\n        src = dataMain.split('/');\n        dataMain = src.pop();\n        subPath = src.length ? src.join('/')  + '/' : './';\n\n        topReq.config({baseUrl: subPath});\n      }\n\n      topReq([dataMain]);\n    }\n  }\n}(this, (typeof Promise !== 'undefined' ? Promise : undefined)));\n"],"sourceRoot":"/source/"}