{"version":3,"file":"app.js","sources":["../../__babelHelpers__","views/navigation-menu.jsx","views/base-view.jsx","views/user-login.jsx","controllers/users.js","views/services-list-item.jsx","views/services-list.jsx","views/services.jsx","controllers/services.js","views/services/camera.jsx","views/services/light.jsx","views/services/default.jsx","views/service.jsx","controllers/service.js","views/tag-list.jsx","views/service-tags.jsx","controllers/service-tags.js","views/themes-list-item.jsx","views/themes.jsx","views/themes-new.jsx","controllers/themes.js","views/dev/camera-latest-image.jsx","controllers/dev.js","lib/foxbox/common/event-dispatcher.js","lib/foxbox/settings.js","lib/foxbox/common/defer.js","lib/foxbox/db.js","lib/foxbox/common/sequential-timer.js","lib/foxbox/box-link.js","lib/foxbox/network.js","lib/foxbox/recipes.js","lib/foxbox/webpush.js","lib/foxbox/services/base.js","lib/foxbox/services/ip-camera.js","lib/foxbox/services/light.js","lib/foxbox/services/door-lock.js","lib/foxbox/services/motion-sensor.js","lib/foxbox/services.js","lib/foxbox/api.js","lib/foxbox/foxbox.js","controllers/main.js","app.js"],"sourcesContent":["var babelHelpers = {};\nexport var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\n\nexport var jsx = function () {\n  var REACT_ELEMENT_TYPE = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n  return function createRawReactElement(type, props, key, children) {\n    var defaultProps = type && type.defaultProps;\n    var childrenLength = arguments.length - 3;\n\n    if (!props && childrenLength !== 0) {\n      props = {};\n    }\n\n    if (props && defaultProps) {\n      for (var propName in defaultProps) {\n        if (props[propName] === void 0) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    } else if (!props) {\n      props = defaultProps || {};\n    }\n\n    if (childrenLength === 1) {\n      props.children = children;\n    } else if (childrenLength > 1) {\n      var childArray = Array(childrenLength);\n\n      for (var i = 0; i < childrenLength; i++) {\n        childArray[i] = arguments[i + 3];\n      }\n\n      props.children = childArray;\n    }\n\n    return {\n      $$typeof: REACT_ELEMENT_TYPE,\n      type: type,\n      key: key === undefined ? null : '' + key,\n      ref: null,\n      props: props,\n      _owner: null\n    };\n  };\n}();\n\nexport var asyncToGenerator = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            return step(\"next\", value);\n          }, function (err) {\n            return step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\nexport var classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nexport var createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexport var defineEnumerableProperties = function (obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n\n  return obj;\n};\n\nexport var defaults = function (obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n};\n\nexport var defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nexport var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexport var get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nexport var inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nexport var _instanceof = function (left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n};\n\nexport var interopRequireDefault = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n};\n\nexport var interopRequireWildcard = function (obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n};\n\nexport var newArrowCheck = function (innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n};\n\nexport var objectDestructuringEmpty = function (obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n};\n\nexport var objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nexport var possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nexport var selfGlobal = typeof global === \"undefined\" ? self : global;\n\nexport var set = function set(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nexport var slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexport var slicedToArrayLoose = function (arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    var _arr = [];\n\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {\n      _arr.push(_step.value);\n\n      if (i && _arr.length === i) break;\n    }\n\n    return _arr;\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n};\n\nexport var taggedTemplateLiteral = function (strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n};\n\nexport var taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nexport var temporalRef = function (val, name, undef) {\n  if (val === undef) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  } else {\n    return val;\n  }\n};\n\nexport var temporalUndefined = {};\n\nexport var toArray = function (arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n};\n\nexport var toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nbabelHelpers;\n\nexport { _typeof as typeof, _extends as extends, _instanceof as instanceof }","import React from 'components/react';\n\nexport default class NavigationMenu extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.foxbox = props.foxbox;\n  }\n\n  shouldComponentUpdate() {\n    // We never need to update this component as it is being recreated each time\n    // the route changes.\n    return false;\n  }\n\n  handleOnClick() {\n    this.foxbox.logout();\n  }\n\n  render() {\n    const route = location.hash.substr(1).split('/').shift();\n    let menuNodes = [\n      {\n        id: 'services',\n        label: 'Home',\n      },\n      {\n        id: 'themes',\n        label: 'Themes',\n      },\n      {\n        id: 'mr-fox',\n        label: 'Mr. Fox',\n      },\n    ].map((menu) => {\n      let className = 'navigation-menu__item';\n      if (route === menu.id) {\n        className += ' navigation-menu__item--active';\n      }\n\n      return (\n        <li key={menu.id} className={className}>\n          <a href={`#${menu.id}`}\n             className=\"navigation-menu__item-link\">\n            {menu.label}\n          </a>\n        </li>\n      );\n    });\n\n    return (\n      <ul className=\"navigation-menu\">\n        {menuNodes}\n        <li className=\"navigation-menu__item\">\n          <a href=\"#users/login\"\n             className=\"navigation-menu__item-link user-logout-button\"\n             onClick={this.handleOnClick.bind(this)}>\n            Log out\n          </a>\n        </li>\n      </ul>\n    );\n  }\n}\n\nNavigationMenu.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport NavigationMenu from './navigation-menu';\n\nexport default class BaseView extends React.Component {\n  renderHeader(title, cssClass) {\n    let className = 'app-view__header';\n    if (cssClass) {\n      className += ` ${cssClass}`;\n    }\n\n    return (\n      <header className={className}>\n        <h1>{title}</h1>\n      </header>\n    );\n  }\n\n  renderFooter() {\n    return (\n      <footer className=\"app-view__footer\">\n        <NavigationMenu foxbox={this.props.foxbox}/>\n      </footer>\n    );\n  }\n\n  renderBody() {\n    return null;\n  }\n\n  render() {\n    return (\n      <div className=\"app-view\">\n        {this.renderHeader()}\n        <section className=\"app-view__body\">{this.renderBody()}</section>\n        {this.renderFooter()}\n      </div>\n    );\n  }\n}\n\nBaseView.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\n\nexport default class UserLogin extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      boxes: props.foxbox.boxes,\n      selectedBox: null,\n      loginEnabled: props.foxbox.online,\n    };\n\n    this.foxbox = props.foxbox;\n\n    this.onBoxOnline = this.onBoxOnline.bind(this);\n    this.onBoxDiscovery = this.onBoxDiscovery.bind(this);\n    this.onSelectChange = this.onSelectChange.bind(this);\n    this.onFormSubmit = this.onFormSubmit.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.addEventListener('online', this.onBoxOnline);\n    this.foxbox.addEventListener('discovery', this.onBoxDiscovery);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.removeEventListener('online', this.onBoxOnline);\n    this.foxbox.removeEventListener('discovery', this.onBoxDiscovery);\n  }\n\n  onSelectChange(evt) {\n    const selectedBox = evt.target.selectedIndex;\n\n    this.setState({ selectedBox });\n    this.foxbox.selectBox(selectedBox);\n  }\n\n  onFormSubmit(evt) {\n    evt.preventDefault(); // Avoid redirection to /?.\n\n    this.foxbox.login();\n  }\n\n  onBoxOnline(loginEnabled) {\n    this.setState({ loginEnabled });\n  }\n\n  onBoxDiscovery() {\n    this.setState({ boxes: this.foxbox.boxes });\n  }\n\n  renderHeader() {\n    return super.renderHeader('Project Link', 'app-view__header--white');\n  }\n\n  renderFooter() {\n    return null;\n  }\n\n  renderBody() {\n    let boxNodes = null;\n\n    if (this.state.boxes.length > 1) {\n      let selectedBox = this.state.selectedBox || 0;\n      const optionNodes = this.state.boxes.map((box, index) => {\n        if (box.client === this.foxbox.client) {\n          selectedBox = index;\n        }\n\n        return (\n          <option key={box.client} value={index}>{box.client}</option>\n        );\n      });\n\n      boxNodes = (<select\n        className=\"user-login__box-selector\"\n        value={selectedBox}\n        onChange={this.onSelectChange}>{optionNodes}</select>);\n    }\n\n    return (\n      <form className=\"app-view__fill-body user-login\"\n            onSubmit={this.onFormSubmit}>\n        <img className=\"user-login__logo\" src=\"img/icon.svg\"/>\n        {boxNodes}\n        <button className=\"user-login__login-button\"\n                disabled={!this.state.loginEnabled}>Connect to your box\n        </button>\n      </form>\n    );\n  }\n}\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\nimport { Controller } from 'components/mvc';\n\nimport UserLogin from '../views/user-login';\n\nconst ALLOWED_ACTIONS = ['login', 'logout'];\nconst DEFAULT_ACTION = ALLOWED_ACTIONS[0];\n\nexport default class UsersController extends Controller {\n  main(action = DEFAULT_ACTION) {\n    if (!ALLOWED_ACTIONS.includes(action)) {\n      console.error(\n        `Bad users route: \"${action}\". Falling back to ${DEFAULT_ACTION}.`\n      );\n      action = DEFAULT_ACTION;\n    }\n\n    switch (action) {\n      case 'login':\n        this.login();\n        break;\n\n      case 'logout':\n        this.logout();\n        break;\n    }\n  }\n\n  login() {\n    ReactDOM.render(\n      React.createElement(UserLogin, { foxbox: this.foxbox }), this.mountNode\n    );\n  }\n\n  logout() {\n    this.foxbox.logout();\n\n    // Once logged out, we redirect to the login page.\n    location.hash = '#users/login';\n  }\n}\n","import React from 'components/react';\n\nexport default class ServicesListItem extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      available: false,\n      on: true,\n      locked: true,\n      motionDetected: false,\n    };\n\n    this.service = props.service;\n    this.foxbox = props.foxbox;\n\n    this.onMotion = this.onMotion.bind(this);\n  }\n\n  componentDidMount() {\n    switch (this.service.type) {\n      case 'light':\n        this.service.isAvailable()\n          .then((available) => {\n            this.setState({ available });\n          })\n          .catch(console.error.bind(console));\n\n        this.service.isOn()\n          .then((on) => {\n            this.setState({ on });\n          })\n          .catch(console.error.bind(console));\n        break;\n      case 'motion-sensor':\n        this.service.isMotionDetected()\n          .then(this.onMotion);\n        this.service.watch('motion', this.onMotion);\n        break;\n      case 'door-lock':\n        this.service.isLocked()\n          .then((locked) => {\n            this.setState({ locked });\n          })\n          .catch((error) => {\n            console.error('Can not retrieve door lock status: %o', error);\n          });\n        break;\n    }\n  }\n\n  componentWillUnmount() {\n    switch (this.service.type) {\n      case 'motion-sensor':\n        this.service.unwatch('motion', this.onMotion);\n        break;\n    }\n  }\n\n  handleLightOnChange(evt) {\n    const on = evt.target.checked;\n\n    // Optimistic update.\n    this.setState({ on });\n\n    this.service.turn(on)\n      .catch((error) => {\n        // Revert back to the previous value.\n        this.setState({ on: !on });\n        console.error(error);\n      });\n  }\n\n  onDoorLockUnlock(evt) {\n    const locked = evt.target.checked;\n\n    this.setState({ locked });\n\n    this.service.lockUnlock(locked)\n      .catch((error) => {\n        // Revert back to the previous value.\n        this.setState({ locked: !locked });\n        console.error('Could not change door lock status: %o', error);\n      });\n  }\n\n  onMotion(motionDetected) {\n    this.setState({ motionDetected });\n  }\n\n  /**\n   * Convert colours from xy space to RGB.\n   * See details at:\n   * http://www.developers.meethue.com/documentation/color-conversions-rgb-xy\n   *\n   * @return {string}\n   */\n  getBulbColour() {\n    const hue = /* this.service.hue */ 1;\n    const sat = /* this.service.sat */ 1;\n    const val = /* this.service.val */ 1;\n    const h = hue;\n    const s = Math.round(sat * 100);\n    const l = val;\n\n    // We set the luminosity to 50% and use the brightness as the opacity. The\n    // brighter, the more opaque. Pale shades get transparent.\n    return `hsla(${h},${s}%,50%,${l})`;\n  }\n\n  renderLightService() {\n    let isConnected = this.state.available;\n\n    let serviceType = 'Light';\n    let icon = 'light';\n\n    if (this.service.model !== undefined) {\n      switch (this.service.model) {\n        case 'BSB002':\n          icon = 'bridge_v2';\n          break;\n\n        case 'LCT001':\n        case 'LCT007':\n        case 'LCT010':\n        case 'LTW010':\n        case 'LWB004':\n        case 'LWB006':\n          icon = 'white_and_color_e27_b22';\n          break;\n\n        case 'LWB010':\n        case 'LWB014':\n          icon = 'white_e27_b22';\n          break;\n\n        case 'LCT002':\n        case 'LCT011':\n        case 'LTW011':\n        case 'LWB005':\n        case 'LWB011':\n          icon = 'br30';\n          break;\n\n        case 'LCT003':\n          icon = 'gu10_par16';\n          break;\n\n        case 'LST001':\n        case 'LST002':\n          icon = 'lightstrip';\n          break;\n\n        case 'LLC006':\n        case 'LLC010':\n          icon = 'iris';\n          break;\n\n        case 'LLC005':\n        case 'LLC011':\n        case 'LLC012':\n        case 'LLC007':\n          icon = 'bloom';\n          break;\n\n        case 'LLC014':\n          icon = 'aura';\n          break;\n\n        case 'LLC013':\n          icon = 'storylight';\n          break;\n\n        case 'LLC020':\n          icon = 'go';\n          break;\n\n        case 'HBL001':\n        case 'HBL002':\n        case 'HBL003':\n          icon = 'beyond_ceiling_pendant_table';\n          break;\n\n        case 'HIL001':\n        case 'HIL002':\n          icon = 'impulse';\n          break;\n\n        case 'HEL001':\n        case 'HEL002':\n          icon = 'entity';\n          break;\n\n        case 'HML001':\n        case 'HML002':\n        case 'HML003':\n        case 'HML004':\n        case 'HML005':\n        case 'HML006':\n          icon = 'phoenix_ceiling_pendant_table_wall';\n          break;\n\n        case 'HML007':\n          icon = 'phoenix_recessed_spot';\n          break;\n\n        case 'SWT001':\n          icon = 'tap';\n          break;\n\n        case 'RWL021':\n          icon = 'hds';\n          break;\n      }\n    }\n\n    const serviceName = this.getServiceName();\n    const serviceNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    return (\n      <li className=\"service-list__item\" data-icon={icon}\n          data-connected={isConnected}>\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          {serviceType}\n          {serviceNameNode}\n        </a>\n        <div className=\"service-list__item-color-picker\"\n             style={{ background: this.getBulbColour() }}>\n        </div>\n        <label>\n          <input className=\"service-list__on-off-toggle\" type=\"checkbox\"\n                 checked={this.state.on} disabled={!isConnected}\n                 onChange={this.handleLightOnChange.bind(this)}/>\n        </label>\n      </li>\n    );\n  }\n\n  renderDoorLock() {\n    const serviceName = this.getServiceName();\n    const serviceNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    return (\n      <li className=\"service-list__item\" data-icon=\"door-lock\">\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          Door Lock\n          {serviceNameNode}\n        </a>\n        <label>\n          <input className=\"service-list__on-off-toggle\" type=\"checkbox\"\n                 checked={this.state.locked}\n                 onChange={this.onDoorLockUnlock.bind(this)}/>\n        </label>\n      </li>\n    );\n  }\n\n  renderMotionSensor() {\n    const serviceName = this.getServiceName();\n    const motionSensorNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    let motionSensorClassName = 'service-list__item motion-sensor-item';\n    if (this.state.motionDetected) {\n      motionSensorClassName += ' motion-sensor-item--motion-detected';\n    }\n\n    return (\n      <li className={motionSensorClassName}>\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          Motion Sensor\n          {motionSensorNameNode}\n        </a>\n      </li>\n    );\n  }\n\n  renderGenericService(type = 'Unknown service', icon = 'unknown') {\n    const serviceName = this.getServiceName();\n    const serviceNameNode = serviceName ?\n      (<small>{` (${serviceName})`}</small>) :\n      null;\n\n    return (\n      <li className=\"service-list__item\" data-icon={icon} data-connected=\"true\">\n        <a className=\"service-list__item-link\"\n           href={`#services/${this.service.id}`}>\n          {type}\n          {serviceNameNode}\n        </a>\n      </li>\n    );\n  }\n\n  render() {\n    switch (this.service.type) {\n      case 'door-lock':\n        return this.renderDoorLock();\n      case 'ip-camera':\n        return this.renderGenericService('Camera', 'ip-camera');\n      case 'light':\n        return this.renderLightService();\n      case 'motion-sensor':\n        return this.renderMotionSensor();\n      default:\n        return this.renderGenericService();\n    }\n  }\n\n  getServiceName() {\n    // If service has tags, let's use them as service identifier.\n    return this.service.getTags().join(', ') || this.service.name;\n  }\n}\n\nServicesListItem.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport ServicesListItem from './services-list-item';\n\nexport default class ServicesList extends React.Component {\n  render() {\n    const knownServices = this.props.services.filter(\n      (service) => service.type !== 'unknown'\n    );\n\n    const serviceNodes = knownServices.map((service) => (\n        <ServicesListItem\n          key={service.id}\n          service={service}\n          foxbox={this.props.foxbox}/>\n      )\n    );\n\n    return (\n      <ul className=\"service-list\">{serviceNodes}</ul>\n    );\n  }\n}\n\nServicesList.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  services: React.PropTypes.array.isRequired,\n};\n","import React from 'components/react';\n\nimport ServicesListView from './services-list';\nimport BaseView from './base-view';\n\nexport default class Services extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      services: [],\n\n      title: '',\n      body: '',\n    };\n\n    this.foxbox = props.foxbox;\n\n    this.updateServiceList = this.updateServiceList.bind(this);\n    this.updateServiceState = this.updateServiceState.bind(this);\n  }\n\n  componentDidMount() {\n    this.updateServiceList();\n\n    this.foxbox.services.togglePolling(true);\n\n    this.foxbox.services.on('services-changed', this.updateServiceList);\n    this.foxbox.services.on('service-changed', this.updateServiceState);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.togglePolling(false);\n\n    this.foxbox.services.off('services-changed', this.updateServiceList);\n    this.foxbox.services.off('service-changed', this.updateServiceState);\n  }\n\n  updateServiceList() {\n    this.foxbox.services.getAll()\n      .then((services) => this.setState({ services }))\n      .catch((error) => {\n        console.error('Could not update service list: %o', error);\n      });\n  }\n\n  updateServiceState(state) {\n    // Find the index of the service which state has changed.\n    const serviceId = this.state.services.findIndex(\n      (service) => service.id === state.id\n    );\n    const services = this.state.services;\n\n    // Update the new state.\n    services[serviceId] = state;\n    this.setState({ services });\n  }\n\n  renderHeader() {\n    return super.renderHeader('My Home');\n  }\n\n  renderBody() {\n    return (\n      <div className=\"app-view__fill-body\">\n        <h2>General</h2>\n        <ServicesListView services={this.state.services} foxbox={this.foxbox} />\n      </div>\n    );\n  }\n}\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\nimport { Controller } from 'components/mvc';\n\nimport Services from '../views/services';\n\nexport default class ServicesController extends Controller {\n  main() {\n    ReactDOM.render(React.createElement(Services, {\n      foxbox: this.foxbox,\n    }), this.mountNode);\n  }\n}\n","import React from 'components/react';\n\nexport default class CameraService extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      hasPreview: false,\n      hasPreviousSnapshot: false,\n    };\n\n    this.foxbox = props.foxbox;\n    this.service = props.service;\n  }\n\n  /**\n   * Takes camera snapshot and displays it to the user.\n   *\n   * @private\n   */\n  takeSnapshot() {\n    this.service.takeSnapshot()\n      .then((image) => {\n        const previousSnapshot = this.refs.snapshotPreview.src;\n\n        const newState = {\n          hasPreview: true,\n          hasPreviousSnapshot: false,\n        };\n\n        this.refs.snapshotPreview.src = URL.createObjectURL(image);\n\n        if (previousSnapshot) {\n          newState.hasPreviousSnapshot = true;\n\n          if (this.refs.previousSnapshot.src) {\n            URL.revokeObjectURL(this.refs.previousSnapshot.src);\n          }\n\n          this.refs.previousSnapshot.src = previousSnapshot;\n        }\n\n        this.setState(newState);\n      })\n      .catch((error) => {\n        console.error('Error occurred while making a snapshot: ', error);\n      });\n  }\n\n  render() {\n    let cameraControlsClass = 'app-view__fill-body camera-controls';\n\n    if (this.state.hasPreview) {\n      cameraControlsClass += ' camera-controls--has-preview';\n    }\n\n    if (this.state.hasPreviousSnapshot) {\n      cameraControlsClass += ' camera-controls--has-previous-snapshot';\n    }\n\n    return (\n      <div className={cameraControlsClass}>\n        <img ref=\"snapshotPreview\"\n             alt={'Snapshot preview'} className=\"camera-controls__preview\" />\n        <div className=\"camera-controls__empty-preview\">\n          <p>Preview is not available.</p>\n          <p>Touch button to take a snapshot!</p>\n        </div>\n        <section className=\"camera-controls__snapshot-tools\">\n          <button className=\"camera-controls__snapshot-btn\" type=\"button\"\n                  title=\"Take a snapshot\"\n                  onClick={this.takeSnapshot.bind(this)}>\n          </button>\n          <img ref=\"previousSnapshot\"\n               className=\"camera-controls__previous-snapshot\" />\n        </section>\n      </div>\n    );\n  }\n}\n\nCameraService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nexport default class LightService extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      name: props.service.name,\n    };\n\n    this.foxbox = props.foxbox;\n    this.service = props.service;\n\n    this.onServiceStateChanged = this.onServiceStateChanged.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.services.on('service-changed', this.onServiceStateChanged);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.off('service-changed', this.onServiceStateChanged);\n  }\n\n  onServiceStateChanged(service) {\n    if (service.id !== this.service.id) {\n      return;\n    }\n\n    this.service = service;\n    this.setState({ name: service.name });\n  }\n\n  render() {\n    return (\n      <div className=\"app-view__fill-body default-service__body\">\n        <p className=\"default-service__notice\">\n          Oops, there are no settings available for this service.\n        </p>\n      </div>\n    );\n  }\n}\n\nLightService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nexport default class Service extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      name: props.service.name,\n    };\n\n    this.foxbox = props.foxbox;\n    this.service = props.service;\n\n    this.onServiceStateChanged = this.onServiceStateChanged.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.services.on('service-changed', this.onServiceStateChanged);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.off('service-changed', this.onServiceStateChanged);\n  }\n\n  onServiceStateChanged(service) {\n    if (service.id !== this.service.id) {\n      return;\n    }\n\n    this.service = service;\n    this.setState({ name: service.name });\n  }\n\n  render() {\n    return (\n      <div className=\"app-view__fill-body default-service__body\">\n        <p className=\"default-service__notice\">\n          Oops, there are no settings available for this service.\n        </p>\n      </div>\n    );\n  }\n}\n\nService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  service: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\nimport CameraServiceView from './services/camera';\nimport LightServiceView from './services/light';\nimport DefaultServiceView from './services/default';\n\nexport default class Service extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      service: null,\n    };\n\n    this.foxbox = props.foxbox;\n  }\n\n  componentDidMount() {\n    this.foxbox.services.get(this.props.id)\n      .then((service) => {\n        this.setState({ service });\n      })\n      .catch((error) => {\n        console.error('Error occurred while retrieving service: ', error);\n      });\n  }\n\n  renderHeader() {\n    if (!this.state.service) {\n      return super.renderHeader('Unknown Service');\n    }\n\n    const serviceName = this.state.service.name ?\n      this.state.service.name :\n      'Unknown Service';\n\n    return (\n      <header className=\"app-view__header\">\n        <h1>{serviceName}</h1>\n        <a href={`#services/${this.state.service.id}/tags`}\n           title=\"Edit tags\"\n           className=\"service__edit-tags-link\">\n          <img className=\"app-view__action-icon\"\n               src=\"css/icons/tag.svg\"\n               alt=\"Edit tags\"/>\n        </a>\n      </header>\n    );\n  }\n\n  renderBody() {\n    if (!this.state.service) {\n      return null;\n    }\n\n    switch (this.state.service.type) {\n      case 'ip-camera':\n        return (<CameraServiceView service={this.state.service}\n                                   foxbox={this.foxbox}/>);\n      case 'light':\n        return (<LightServiceView service={this.state.service}\n                                  foxbox={this.foxbox}/>);\n      default:\n        return (<DefaultServiceView service={this.state.service}\n                                    foxbox={this.foxbox}/>);\n    }\n  }\n}\n\nService.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  id: React.PropTypes.string.isRequired,\n};\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\nimport { Controller } from 'components/mvc';\n\nimport Service from '../views/service';\n\nexport default class ServiceController extends Controller {\n  main(id) {\n    ReactDOM.render(React.createElement(Service, {\n      id,\n      foxbox: this.foxbox,\n    }), this.mountNode);\n  }\n}\n","import React from 'components/react';\n\nexport default class TagList extends React.Component {\n  render() {\n    let tagNodes = this.props.tags.map((tag) => (\n      <li key={tag} className=\"tag-list__item\">\n        {tag}\n        <button className=\"tag-list__item-remove\"\n                type=\"button\"\n                onClick={this.props.onRemoveTag.bind(null, tag)}\n                title=\"Remove tag\"></button>\n      </li>\n    ));\n\n    return (\n      <ul className=\"tag-list\">{tagNodes}</ul>\n    );\n  }\n}\n\nTagList.propTypes = {\n  tags: React.PropTypes.array.isRequired,\n  onRemoveTag: React.PropTypes.func.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\nimport TagList from './tag-list';\n\nexport default class ServiceTags extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = { service: null, tags: [] };\n    this.foxbox = props.foxbox;\n\n    this.onServiceStateChanged = this.onServiceStateChanged.bind(this);\n  }\n\n  componentDidMount() {\n    this.foxbox.services.get(this.props.id)\n      .then((service) => {\n        this.setState({ service, tags: service.getTags() });\n      })\n      .catch((error) => {\n        console.error('Error occurred while retrieving service: ', error);\n      });\n\n    this.foxbox.services.on('service-changed', this.onServiceStateChanged);\n  }\n\n  componentWillUnmount() {\n    this.foxbox.services.off('service-changed', this.onServiceStateChanged);\n  }\n\n  onServiceStateChanged(service) {\n    if (service.id !== this.props.id) {\n      return;\n    }\n\n    this.setState({ service, tags: service.getTags() });\n  }\n\n  onAddTag() {\n    const service = this.state.service;\n    if (!service) {\n      return;\n    }\n\n    const tag = (prompt('Enter new tag name') || '').trim();\n    if (!tag) {\n      return;\n    }\n\n    service.addTag(tag)\n      .catch((err) => {\n        // Restore actual tag list if server failed to add tag.\n        console.error(`Could not add the tag \"${tag}\": %o`, err);\n        this.setState({ tags: service.getTags() });\n      });\n\n    this.setState({ tags: service.getTags() });\n  }\n\n  onRemoveTag(tag) {\n    const service = this.state.service;\n\n    service.removeTag(tag)\n      .catch((err) => {\n        // Restore actual tag list if server failed to remove tag.\n        console.error(`Could not remove the tag \"${tag}\": %o`, err);\n        this.setState({ tags: service.getTags() });\n      });\n\n    this.setState({ tags: service.getTags() });\n  }\n\n  renderHeader() {\n    const service = this.state.service;\n    return super.renderHeader(\n      service && service.name ?\n        service.name :\n        'Unknown Service'\n    );\n  }\n\n  renderBody() {\n    return (\n      <div className=\"app-view__fill-body\">\n        <h2>Tags</h2>\n        <TagList tags={this.state.tags}\n                 onRemoveTag={this.onRemoveTag.bind(this)} />\n        <button className=\"add-tag-button\" type=\"button\"\n                onClick={this.onAddTag.bind(this)}>\n          Create a new tag\n        </button>\n      </div>\n    );\n  }\n}\n\nServiceTags.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  id: React.PropTypes.string.isRequired,\n};\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\nimport { Controller } from 'components/mvc';\n\nimport ServiceTagsView from '../views/service-tags';\n\nexport default class ServiceTagsController extends Controller {\n  main(id) {\n    ReactDOM.render(React.createElement(ServiceTagsView, {\n      id,\n      foxbox: this.foxbox,\n    }), this.mountNode);\n  }\n}\n","import React from 'components/react';\n\nexport default class ThemesListItem extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      enabled: props.theme.enabled,\n    };\n\n    this.foxbox = props.foxbox;\n    this.handleOnChange = this.handleOnChange.bind(this);\n    this.handleOnDelete = this.handleOnDelete.bind(this);\n  }\n\n  /**\n   * Activate or deactivate a recipe.\n   *\n   * @param {SyntheticEvent} evt\n   */\n  handleOnChange(evt) {\n    const enabled = evt.target.checked;\n\n    this.setState({ enabled }); // Optimistic update.\n\n    this.foxbox.recipes.toggle(this.props.theme, enabled)\n      .catch((error) => {\n        this.setState({ enabled: !enabled }); // Revert back to previous value.\n        console.error(error);\n      });\n  }\n\n  /**\n   * Delete a recipe.\n   */\n  handleOnDelete() {\n    this.foxbox.recipes.remove(this.props.theme)\n      .then(() => {\n        this.props.update();\n      })\n      .catch(console.error.bind(console));\n  }\n\n  render() {\n    let className = 'themes-list__item';\n    if (!this.state.enabled) {\n      className += ' themes-list__item--deactivated';\n    }\n\n    return (\n      <li className={className}>\n        <input className=\"themes-list__toggle\"\n               type=\"checkbox\"\n               checked={this.state.enabled}\n               onChange={this.handleOnChange}/>\n        <span className=\"themes-list__name\">{this.props.theme.label}</span>\n        <button className=\"themes-list__remove\"\n                onClick={this.handleOnDelete}></button>\n      </li>\n    );\n  }\n}\n\nThemesListItem.propTypes = {\n  theme: React.PropTypes.object.isRequired,\n  update: React.PropTypes.func.isRequired,\n  foxbox: React.PropTypes.object.isRequired,\n};\n","import React from 'components/react';\n\nimport BaseView from './base-view';\nimport ThemesListItemView from './themes-list-item';\n\n// @todo Allow editing existing recipes when clicking on the label.\n\nexport default class Themes extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      themes: [],\n    };\n\n    this.foxbox = props.foxbox;\n    this.update = this.update.bind(this);\n  }\n\n  componentDidMount() {\n    this.update();\n  }\n\n  update() {\n    this.foxbox.recipes.getAll()\n      .then((themes) => {\n        this.setState({ themes });\n      })\n      .catch(console.error.bind(console));\n  }\n\n  renderHeader() {\n    return (\n      <header className=\"app-view__header\">\n        <h1>Recipes</h1>\n        <a href=\"#themes/new\" className=\"themes__new-link\">\n          <img className=\"app-view__action-icon\"\n               src=\"css/icons/plus.svg\"\n               alt=\"Add a recipe\"/>\n        </a>\n      </header>\n    );\n  }\n\n  renderBody() {\n    const themeItems = this.state.themes.map((theme) => (\n      <ThemesListItemView key={theme.id}\n                          theme={theme}\n                          update={this.update}\n                          foxbox={this.foxbox} />\n    ));\n\n    return (\n      <div className=\"app-view__fill-body themes\">\n        <ul className=\"themes-list\">{themeItems}</ul>\n      </div>\n    );\n  }\n}\n","import React from 'components/react';\n\nimport BaseView from './base-view';\n\n// @todo Validate input on select onChange:\n//    * Check if integer\n//    * Check if value is within boundaries\n//    * Check if properties belong to selected service\n\nexport default class ThemesNew extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      getters: [],\n      setters: [],\n\n      selectedGetterIndex: -1,\n      selectedGetterValueIndex: -1,\n\n      selectedSetterIndex: -1,\n      selectedSetterValueIndex: -1,\n    };\n\n    this.foxbox = props.foxbox;\n\n    this.updateServices = this.updateServices.bind(this);\n    this.onGetterSelected = this.onGetterSelected.bind(this);\n    this.onGetterValueSelected = this.onGetterValueSelected.bind(this);\n    this.onSetterSelected = this.onSetterSelected.bind(this);\n    this.onSetterValueSelected = this.onSetterValueSelected.bind(this);\n    this.onSaveRecipe = this.onSaveRecipe.bind(this);\n  }\n\n  componentDidMount() {\n    Promise.all([\n      this.foxbox.recipes.getGetters(),\n      this.foxbox.recipes.getSetters(),\n    ])\n    .then((services) => this.updateServices(services))\n    .catch(console.error.bind(console));\n  }\n\n  updateServices([getters, setters] = [[], []]) {\n    this.setState({ getters, setters });\n  }\n\n  onGetterSelected(evt) {\n    let selectedGetterIndex = -1;\n\n    if (evt.target.value) {\n      selectedGetterIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedGetterIndex,\n      selectedGetterValueIndex: -1,\n\n      selectedSetterIndex: -1,\n      selectedSetterValueIndex: -1,\n    });\n  }\n\n  onGetterValueSelected(evt) {\n    let selectedGetterValueIndex = -1;\n\n    if (evt.target.value) {\n      selectedGetterValueIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedGetterValueIndex,\n\n      selectedSetterIndex: -1,\n      selectedSetterValueIndex: -1,\n    });\n  }\n\n  onSetterSelected(evt) {\n    let selectedSetterIndex = -1;\n\n    if (evt.target.value) {\n      selectedSetterIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedSetterIndex,\n      selectedSetterValueIndex: -1,\n    });\n  }\n\n  onSetterValueSelected(evt) {\n    let selectedSetterValueIndex = -1;\n\n    if (evt.target.value) {\n      selectedSetterValueIndex = Number(evt.target.value);\n    }\n\n    this.setState({\n      selectedSetterValueIndex,\n    });\n  }\n\n  onSaveRecipe() {\n    if (this.state.selectedSetterValueIndex < 0) {\n      return;\n    }\n\n    const getter = this.state.getters[this.state.selectedGetterIndex];\n    const getterValue = getter.options[this.state.selectedGetterValueIndex];\n\n    const setter = this.state.setters[this.state.selectedSetterIndex];\n    const setterValue = setter.options[this.state.selectedSetterValueIndex];\n\n    const name = `${getter.name} ${getterValue.label}, ` +\n      `${setter.name} ${setterValue.label}.`;\n\n    this.foxbox.recipes.add({\n      name,\n      getter,\n      getterValue,\n      setter,\n      setterValue,\n    })\n    .then(() => {\n      location.hash = '#themes';\n    })\n    .catch((error) => {\n      console.log('Error occurred while saving recipe: ', error);\n    });\n  }\n\n  renderHeader() {\n    let actionButtonClassName = 'app-view__action';\n    if (this.state.setter === null) {\n      actionButtonClassName += ' app-view__action--disabled';\n    }\n\n    return (\n      <header className=\"app-view__header\">\n        <a href=\"#themes\" className=\"app-view__action\">Cancel</a>\n        <h1>New Recipe</h1>\n        <button className={actionButtonClassName}\n                onClick={this.onSaveRecipe}>Done\n        </button>\n      </header>\n    );\n  }\n\n  renderBody() {\n    let headerClassName = 'new-theme__header';\n    if (this.state.selectedGetterValueIndex < 0) {\n      headerClassName += ' new-theme__header--hidden';\n    }\n\n    return (\n      <div className=\"app-view__fill-body new-theme\">\n        <h2 className=\"new-theme__header\">If</h2>\n        {this.renderGetterSelector()}\n        {this.renderGetterValueSelector()}\n\n        <h2 className={headerClassName}>Do</h2>\n        {this.renderSetterSelector()}\n        {this.renderSetterValueSelector()}\n      </div>\n    );\n  }\n\n  renderGetterSelector() {\n    let className = 'new-theme__select';\n    if (this.state.selectedGetterIndex >= 0) {\n      className += ' new-theme__select--selected';\n    }\n\n    const optionNodes = this.state.getters.map((getter, index) => (\n      <option key={index} value={index}>{this.getChannelName(getter)}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedGetterIndex}\n              onChange={this.onGetterSelected}\n              className={className}>\n        <option value=\"\">Select a device</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  renderGetterValueSelector() {\n    if (this.state.selectedGetterIndex < 0) {\n      // @todo Rethink styling to avoid redundant element.\n      return (\n        <select className=\"new-theme__select new-theme__select--hidden\">\n        </select>\n      );\n    }\n\n    let className = 'new-theme__select';\n    if (this.state.selectedGetterValueIndex >= 0) {\n      className += ' new-theme__select--selected';\n    }\n\n    const options = this.state.getters[this.state.selectedGetterIndex].options;\n    const optionNodes = options.map((option, index) => (\n      <option key={index} value={index}>{option.label}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedGetterValueIndex}\n              onChange={this.onGetterValueSelected}\n              className={className}>\n        <option value=\"\">Select a property</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  renderSetterSelector() {\n    if (this.state.selectedGetterValueIndex < 0) {\n      return (\n        <select className=\"new-theme__select new-theme__select--hidden\">\n        </select>\n      );\n    }\n\n    let className = 'new-theme__select';\n    if (this.state.selectedSetterIndex >= 0) {\n      className += ' new-theme__select--selected';\n    }\n\n    const optionNodes = this.state.setters.map((setter, index) => (\n      <option key={index} value={index}>{this.getChannelName(setter)}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedSetterIndex}\n              onChange={this.onSetterSelected}\n              className={className}>\n        <option value=\"\">Select a device</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  renderSetterValueSelector() {\n    if (this.state.selectedSetterIndex < 0) {\n      return (\n        <select className=\"new-theme__select new-theme__select--hidden\">\n        </select>\n      );\n    }\n\n    let className = 'new-theme__select';\n    if (this.state.setter !== null) {\n      className += ' new-theme__select--selected';\n    }\n\n    const options = this.state.setters[this.state.selectedSetterIndex].options;\n    const optionNodes = options.map((option, index) => (\n      <option key={index} value={index}>{option.label}</option>\n    ));\n\n    return (\n      <select value={this.state.selectedSetterValueIndex}\n              onChange={this.onSetterValueSelected}\n              className={className}>\n        <option value=\"\">Select a property</option>\n        {optionNodes}\n      </select>\n    );\n  }\n\n  getChannelName(channel) {\n    // If channel has tags, let's use them as channel identifier.\n    const tags = channel.tags.join(', ');\n    return tags ? `${channel.name} (${tags})` : channel.name;\n  }\n}\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\nimport { Controller } from 'components/mvc';\n\nimport Themes from '../views/themes';\nimport ThemesNew from '../views/themes-new';\n\nexport default class ThemesController extends Controller {\n  main(action = 'list') {\n    const props = {\n      foxbox: this.foxbox,\n    };\n\n    switch (action) {\n      case 'list':\n        ReactDOM.render(React.createElement(Themes, props), this.mountNode);\n        break;\n\n      case 'new':\n        ReactDOM.render(React.createElement(ThemesNew, props), this.mountNode);\n        break;\n\n      default:\n        //ReactDOM.render(React.createElement(Theme, props), this.mountNode);\n        break;\n    }\n\n  }\n}\n","import React from 'components/react';\n\nimport BaseView from '../base-view';\n\nexport default class CameraLatestImage extends BaseView {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      service: null,\n      hasPreview: false,\n    };\n\n    this.foxbox = props.foxbox;\n  }\n\n  componentDidMount() {\n    this.foxbox.services.get(this.props.id)\n      .then((service) => {\n        this.setState({ service });\n\n        return service.getLatestImage();\n      })\n      .then((image) => {\n        this.refs.snapshotPreview.src = URL.createObjectURL(image);\n        this.setState({ hasPreview: true });\n      })\n      .catch((error) => {\n        console.error(\n          'Error occurred while retrieving latest image for camera (id=%s): ',\n          this.props.id,\n          error\n        );\n      });\n  }\n\n  renderHeader() {\n    return super.renderHeader(\n      this.state.service && this.state.service.name ?\n        this.state.service.name :\n        'Unknown Service'\n    );\n  }\n\n  renderBody() {\n    let cameraControlsClass = 'app-view__fill-body camera-controls';\n    if (this.state.hasPreview) {\n      cameraControlsClass += ' camera-controls--has-preview';\n    }\n\n    return (\n      <div className={cameraControlsClass}>\n        <img ref=\"snapshotPreview\"\n             style={{ flexGrow: 0 }}\n             alt={'Snapshot preview'} className=\"camera-controls__preview\" />\n        <div className=\"camera-controls__empty-preview\">\n          <p>Preview is being loaded.</p>\n          <p>Wait a moment please!</p>\n        </div>\n      </div>\n    );\n  }\n}\n\nCameraLatestImage.propTypes = {\n  foxbox: React.PropTypes.object.isRequired,\n  id: React.PropTypes.string.isRequired,\n};\n","import React from 'components/react';\nimport ReactDOM from 'components/react-dom';\nimport { Controller } from 'components/mvc';\n\nimport CameraLatestImageView from '../views/dev/camera-latest-image';\n\nexport default class DevController extends Controller {\n  main(path, args) {\n    switch (path) {\n      case 'camera-latest-image':\n        ReactDOM.render(React.createElement(CameraLatestImageView, {\n          id: args,\n          foxbox: this.foxbox,\n        }), this.mountNode);\n        break;\n      default:\n        console.error('Unknown development view path \"%s\"', path);\n        break;\n    }\n  }\n}\n","'use strict';\n\n/*\n * This file provides an helper to add custom events to any object.\n *\n * In order to use this functionality with any object consumer should extend\n * target object class with EventDispatcher:\n *\n * class Obj extends EventDispatcher {}\n * const obj = new Obj();\n *\n * A list of events can be optionally provided and it is recommended to do so.\n * If a list is provided then only the events present in the list will be\n * allowed. Using events not present in the list will cause other functions to\n * throw an error:\n *\n * class Obj extends EventDispatcher {\n *   constructor() {\n *     super(['somethinghappened', 'somethingelsehappened']);\n *   }\n * }\n * const obj = new Obj();\n *\n * The object will have five new methods: 'on', 'once', 'off', 'offAll' and\n * 'emit'. Use 'on' to register a new event-handler:\n *\n * obj.on(\"somethinghappened\", function onSomethingHappened() { ... });\n *\n * If the same event-handler is added multiple times then only one will be\n * registered, e.g.:\n *\n * function onSomethingHappened() { ... }\n * obj.on(\"somethinghappened\", onSomethingHappened);\n * obj.on(\"somethinghappened\", onSomethingHappened); // Does nothing\n *\n * Use 'off' to remove a registered listener:\n *\n * obj.off(\"somethinghappened\", onSomethingHappened);\n *\n * Use 'once' to register a one-time event-handler: it will be automatically\n * unregistered after being called.\n *\n * obj.once(\"somethinghappened\", function onSomethingHappened() { ... });\n *\n * And use 'offAll' to remove all registered event listeners for the specified\n * event:\n *\n * obj.offAll(\"somethinghappened\");\n *\n * When used without parameters 'offAll' removes all registered event handlers,\n * this can be useful when writing unit-tests.\n *\n * Finally use 'emit' to send an event to the registered handlers:\n *\n * obj.emit(\"somethinghappened\");\n *\n * An optional parameter can be passed to 'emit' to be passed to the registered\n * handlers:\n *\n * obj.emit(\"somethinghappened\", 123);\n */\n\nconst assertValidEventName = function(eventName) {\n  if (!eventName || typeof eventName !== 'string') {\n    throw new Error('Event name should be a valid non-empty string!');\n  }\n};\n\nconst assertValidHandler = function(handler) {\n  if (typeof handler !== 'function') {\n    throw new Error('Handler should be a function!');\n  }\n};\n\nconst assertAllowedEventName = function(allowedEvents, eventName) {\n  if (allowedEvents && allowedEvents.indexOf(eventName) < 0) {\n    throw new Error(`Event \"${eventName}\" is not allowed!`);\n  }\n};\n\nconst p = Object.freeze({\n  allowedEvents: Symbol('allowedEvents'),\n  listeners: Symbol('listeners'),\n});\n\nexport default class EventDispatcher {\n  constructor(allowedEvents) {\n    if (typeof allowedEvents !== 'undefined' && !Array.isArray(allowedEvents)) {\n      throw new Error('Allowed events should be a valid array of strings!');\n    }\n\n    this[p.listeners] = new Map();\n    this[p.allowedEvents] = allowedEvents;\n  }\n\n  /**\n   * Registers listener function to be executed once event occurs.\n   *\n   * @param {string} eventName Name of the event to listen for.\n   * @param {function} handler Handler to be executed once event occurs.\n   */\n  on(eventName, handler) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n    assertValidHandler(handler);\n\n    let handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      handlers = new Set();\n      this[p.listeners].set(eventName, handlers);\n    }\n\n    // Set.add ignores handler if it has been already registered.\n    handlers.add(handler);\n  }\n\n  /**\n   * Registers listener function to be executed only first time when event\n   * occurs.\n   *\n   * @param {string} eventName Name of the event to listen for.\n   * @param {function} handler Handler to be executed once event occurs.\n   */\n  once(eventName, handler) {\n    assertValidHandler(handler);\n\n    const once = (parameters) => {\n      this.off(eventName, once);\n\n      handler.call(this, parameters);\n    };\n\n    this.on(eventName, once);\n  }\n\n  /**\n   * Removes registered listener for the specified event.\n   *\n   * @param {string} eventName Name of the event to remove listener for.\n   * @param {function} handler Handler to remove, so it won't be executed\n   * next time event occurs.\n   */\n  off(eventName, handler) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n    assertValidHandler(handler);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.delete(handler);\n\n    if (!handlers.size) {\n      this[p.listeners].delete(eventName);\n    }\n  }\n\n  /**\n   * Removes all registered listeners for the specified event.\n   *\n   * @param {string=} eventName Name of the event to remove all listeners for.\n   */\n  offAll(eventName) {\n    if (typeof eventName === 'undefined') {\n      this[p.listeners].clear();\n      return;\n    }\n\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.clear();\n\n    this[p.listeners].delete(eventName);\n  }\n\n  /**\n   * Emits specified event so that all registered handlers will be called\n   * with the specified parameters.\n   *\n   * @param {string} eventName Name of the event to call handlers for.\n   * @param {Object=} parameters Optional parameters that will be passed to\n   * every registered handler.\n   */\n  emit(eventName, parameters) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    const handlers = this[p.listeners].get(eventName);\n    if (!handlers) {\n      return;\n    }\n\n    handlers.forEach((handler) => {\n      try {\n        handler.call(this, parameters);\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n\n  /**\n   * Checks if there are any listeners that listen for the specified event.\n   *\n   * @param {string} eventName Name of the event to check listeners for.\n   * @returns {boolean}\n   */\n  hasListeners(eventName) {\n    assertValidEventName(eventName);\n    assertAllowedEventName(this[p.allowedEvents], eventName);\n\n    return this[p.listeners].has(eventName);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\n\n// Prefix all entries to avoid collisions.\nconst PREFIX = 'foxbox-';\n\n/**\n * API version to use (currently not configurable).\n * @type {number}\n * @const\n */\nconst API_VERSION = 1;\n\n/**\n * Name of the query string parameter that should be presented in URLs pointing\n * to box endpoints (eg. streams, event sources etc.) if authorisation HTTP\n * header can't be attached.\n * @type {string}\n * @const\n */\nconst QUERY_STRING_AUTH_TOKEN_NAME = 'auth';\n\n/**\n * Regex to match upper case literals.\n * @type {RegExp}\n * @const\n */\nconst UPPER_CASE_REGEX = /([A-Z])/g;\n\nconst p = Object.freeze({\n  values: Symbol('values'),\n  storage: Symbol('storage'),\n\n  // Private methods.\n  updateSetting: Symbol('updateSetting'),\n  stringToSettingTypedValue: Symbol('stringToSettingTypedValue'),\n  getDefaultSettingValue: Symbol('getDefaultSettingValue'),\n  onStorage: Symbol('onStorage'),\n});\n\n// Definition of all available settings and their default values (if needed).\nconst settings = Object.freeze({\n  // Boolean settings.\n  CONFIGURED: Object.freeze({ key: 'configured', type: 'boolean' }),\n  SKIP_DISCOVERY: Object.freeze({ key: 'skipDiscovery', type: 'boolean' }),\n  SERVICE_POLLING_ENABLED: Object.freeze({\n    key: 'servicePollingEnabled',\n    type: 'boolean',\n    defaultValue: true,\n  }),\n\n  // Number settings.\n  SERVICE_POLLING_INTERVAL: Object.freeze({\n    key: 'servicePollingInterval',\n    type: 'number',\n    defaultValue: 2000,\n  }),\n  WATCH_INTERVAL: Object.freeze({\n    key: 'watchInterval',\n    type: 'number',\n    defaultValue: 3000,\n  }),\n  ONLINE_CHECKING_INTERVAL: Object.freeze({\n    key: 'onlineCheckingInterval',\n    type: 'number',\n    defaultValue: 5000,\n  }),\n  ONLINE_CHECKING_LONG_INTERVAL: Object.freeze({\n    key: 'onlineCheckingLongInterval',\n    type: 'number',\n    defaultValue: 1000 * 60 * 5,\n  }),\n\n  // String settings.\n  LOCAL_ORIGIN: Object.freeze({ key: 'localOrigin' }),\n  TUNNEL_ORIGIN: Object.freeze({ key: 'tunnelOrigin' }),\n  CLIENT: Object.freeze({ key: 'client' }),\n  SESSION: Object.freeze({ key: 'session' }),\n  PUSH_ENDPOINT: Object.freeze({ key: 'pushEndpoint' }),\n  PUSH_PUB_KEY: Object.freeze({ key: 'pushPubKey' }),\n  PUSH_AUTH: Object.freeze({ key: 'pushAuth' }),\n  REGISTRATION_SERVICE: Object.freeze({\n    key: 'registrationService',\n    defaultValue: 'https://knilxof.org:4443/ping',\n  }),\n});\n\nexport default class Settings extends EventDispatcher {\n  constructor(storage = localStorage) {\n    super();\n\n    // Not all browsers have localStorage supported or activated.\n    this[p.storage] = storage || {\n      getItem: () => null,\n      setItem: () => {},\n      removeItem: () => {},\n      clear: () => {},\n    };\n\n    this[p.values] = new Map();\n\n    Object.keys(settings).forEach((settingName) => {\n      const setting = settings[settingName];\n      const settingStringValue = this[p.storage].getItem(\n        `${PREFIX}${setting.key}`\n      );\n\n      // Setting values directly to avoid firing events on startup.\n      this[p.values].set(\n        setting,\n        this[p.stringToSettingTypedValue](setting, settingStringValue)\n      );\n    });\n\n    window.addEventListener('storage', this[p.onStorage].bind(this));\n\n    Object.seal(this);\n  }\n\n  get configured() {\n    return this[p.values].get(settings.CONFIGURED);\n  }\n\n  set configured(value) {\n    this[p.updateSetting](settings.CONFIGURED, value);\n  }\n\n  get localOrigin() {\n    return this[p.values].get(settings.LOCAL_ORIGIN);\n  }\n\n  set localOrigin(value) {\n    this[p.updateSetting](\n      settings.LOCAL_ORIGIN,\n      value ? (new URL(value)).origin : null\n    );\n  }\n\n  get tunnelOrigin() {\n    return this[p.values].get(settings.TUNNEL_ORIGIN);\n  }\n\n  set tunnelOrigin(value) {\n    this[p.updateSetting](\n      settings.TUNNEL_ORIGIN,\n      value ? (new URL(value)).origin : null\n    );\n  }\n\n  get client() {\n    return this[p.values].get(settings.CLIENT);\n  }\n\n  set client(value) {\n    this[p.updateSetting](settings.CLIENT, value ? String(value) : null);\n  }\n\n  get session() {\n    return this[p.values].get(settings.SESSION);\n  }\n\n  set session(value) {\n    this[p.updateSetting](settings.SESSION, value);\n  }\n\n  get skipDiscovery() {\n    return this[p.values].get(settings.SKIP_DISCOVERY);\n  }\n\n  set skipDiscovery(value) {\n    this[p.updateSetting](settings.SKIP_DISCOVERY, value);\n  }\n\n  get servicePollingEnabled() {\n    return this[p.values].get(settings.SERVICE_POLLING_ENABLED);\n  }\n\n  set servicePollingEnabled(value) {\n    this[p.updateSetting](settings.SERVICE_POLLING_ENABLED, value);\n  }\n\n  get pushEndpoint() {\n    return this[p.values].get(settings.PUSH_ENDPOINT);\n  }\n\n  set pushEndpoint(value) {\n    this[p.updateSetting](settings.PUSH_ENDPOINT, value);\n  }\n\n  get pushPubKey() {\n    return this[p.values].get(settings.PUSH_PUB_KEY);\n  }\n\n  set pushPubKey(value) {\n    this[p.updateSetting](settings.PUSH_PUB_KEY, value);\n  }\n\n  get pushAuth() {\n    return this[p.values].get(settings.PUSH_AUTH);\n  }\n\n  set pushAuth(value) {\n    this[p.updateSetting](settings.PUSH_AUTH, value);\n  }\n\n  // Getters only.\n  get registrationService() {\n    return this[p.values].get(settings.REGISTRATION_SERVICE);\n  }\n\n  get servicePollingInterval() {\n    return this[p.values].get(settings.SERVICE_POLLING_INTERVAL);\n  }\n\n  get onlineCheckingInterval() {\n    return this[p.values].get(settings.ONLINE_CHECKING_INTERVAL);\n  }\n\n  get onlineCheckingLongInterval() {\n    return this[p.values].get(settings.ONLINE_CHECKING_LONG_INTERVAL);\n  }\n\n  /**\n   * Minimal interval between consequent value watcher requests.\n   * @return {number}\n   */\n  get watchInterval() {\n    return this[p.values].get(settings.WATCH_INTERVAL);\n  }\n\n  get queryStringAuthTokenName() {\n    return QUERY_STRING_AUTH_TOKEN_NAME;\n  }\n\n  get apiVersion() {\n    return API_VERSION;\n  }\n\n  /**\n   * Iterates through all known settings and sets default value for all of them.\n   *\n   * @return {Promise}\n   */\n  clear() {\n    return new Promise((resolve) => {\n      Object.keys(settings).forEach((settingName) => {\n        const setting = settings[settingName];\n        this[p.updateSetting](setting, this[p.getDefaultSettingValue](setting));\n      });\n      resolve();\n    });\n  }\n\n  /**\n   * Tries to update setting with new value. If value has changed corresponding\n   * event will be emitted. New value is also persisted to the local storage.\n   *\n   * @param {Object} setting Setting description object.\n   * @param {number|boolean|string?} newValue New value for specified setting.\n   * @private\n   */\n  [p.updateSetting](setting, newValue) {\n    const currentValue = this[p.values].get(setting);\n    if (currentValue === newValue) {\n      return;\n    }\n\n    this[p.values].set(setting, newValue);\n\n    if (newValue !== this[p.getDefaultSettingValue](setting)) {\n      this[p.storage].setItem(`${PREFIX}${setting.key}`, newValue);\n    } else {\n      this[p.storage].removeItem(`${PREFIX}${setting.key}`);\n    }\n\n    this.emit(\n      setting.key.replace(UPPER_CASE_REGEX, (part) => `-${part.toLowerCase()}`),\n      newValue\n    );\n  }\n\n  /**\n   * Converts setting raw string value to the typed one depending on the setting\n   * type.\n   *\n   * @param {Object} setting Setting description object.\n   * @param {string?} stringValue Raw string setting value or null.\n   * @return {number|boolean|string|null}\n   * @private\n   */\n  [p.stringToSettingTypedValue](setting, stringValue) {\n    // If string is null, we should return default value for this setting or\n    // default value for setting type.\n    if (stringValue === null) {\n      return this[p.getDefaultSettingValue](setting);\n    } else if (setting.type === 'boolean') {\n      return stringValue === 'true';\n    } else if (setting.type === 'number') {\n      return Number(stringValue);\n    }\n\n    return stringValue;\n  }\n\n  /**\n   * Gets default typed value for the specified setting.\n   *\n   * @param {Object} setting Setting description object.\n   * @return {number|boolean|string|null}\n   * @private\n   */\n  [p.getDefaultSettingValue](setting) {\n    if (setting.defaultValue !== undefined) {\n      return setting.defaultValue;\n    }\n\n    // Default value for this setting is not specified, let's return default\n    // value for setting type (boolean, number or string).\n    if (setting.type === 'boolean') {\n      return false;\n    } else if (setting.type === 'number') {\n      return 0;\n    }\n\n    return null;\n  }\n\n  /**\n   * Handles localStorage \"storage\" event.\n   *\n   * @param {StorageEvent} evt StorageEvent instance.\n   * @private\n   */\n  [p.onStorage](evt) {\n    if (!evt.key.startsWith(PREFIX)) {\n      return;\n    }\n\n    const key = evt.key.substring(PREFIX.length);\n    const settingName = Object.keys(settings).find((settingName) => {\n      return settings[settingName].key === key;\n    });\n\n    if (!settingName) {\n      console.warn(\n        `Changed unknown storage entry with app specific prefix: ${evt.key}`\n      );\n      return;\n    }\n\n    const setting = settings[settingName];\n\n    this[p.updateSetting](\n      setting,\n      this[p.stringToSettingTypedValue](setting, evt.newValue)\n    );\n  }\n}\n","'use strict';\n\nconst p = Object.freeze({\n  promise: Symbol('promise'),\n  resolve: Symbol('resolve'),\n  reject: Symbol('reject'),\n});\n\n/**\n * Instance of the Defer class is just a handy wrapper around native Promise\n * object intended to provide dedicated 'resolve' and 'reject' methods.\n */\nexport default class Defer {\n  constructor() {\n    this[p.promise] = new Promise((resolve, reject) => {\n      this[p.resolve] = resolve;\n      this[p.reject] = reject;\n    });\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Actual promise instance.\n   *\n   * @return {Promise}\n   */\n  get promise() {\n    return this[p.promise];\n  }\n\n  /**\n   * Resolves promise with the specified value.\n   *\n   * @param {*=} value Optional value to resolve promise with.\n   */\n  resolve(value) {\n    this[p.resolve](value);\n  }\n\n  /**\n   * Rejects promise with the specified error.\n   *\n   * @param {*=} error Error to reject promise with.\n   */\n  reject(error) {\n    this[p.reject](error);\n  }\n}\n","'use strict';\n\nimport Defer from './common/defer';\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  db: Symbol('db'),\n  initializationStarted: Symbol('initializationStarted'),\n\n  // Private methods.\n  upgradeSchema: Symbol('upgradeSchema'),\n  getAll: Symbol('getAll'),\n  getById: Symbol('getById'),\n  set: Symbol('set'),\n  remove: Symbol('remove'),\n  clearDb: Symbol('clearDb'),\n});\n\n// The name of the db.\nconst DB_NAME = 'foxbox-db';\n\n// The version of the indexed database.\nconst DB_VERSION = 1;\n\nconst DB_SERVICE_STORE = 'services';\n\nexport default class Db {\n  constructor() {\n    this[p.db] = new Defer();\n    this[p.initializationStarted] = false;\n\n    Object.seal(this);\n  }\n\n  init() {\n    // We don't to expose internal DB object outside of DB class.\n    const initializationPromise = this[p.db].promise.then(() => {});\n\n    if (this[p.initializationStarted]) {\n      return initializationPromise;\n    }\n\n    try {\n      const req = indexedDB.open(DB_NAME, DB_VERSION);\n\n      req.onupgradeneeded = this[p.upgradeSchema];\n      req.onsuccess = (evt) => this[p.db].resolve(evt.target.result);\n      req.onerror = (error) => this[p.db].reject(error);\n    } catch(error) {\n      this[p.db].reject(error);\n    }\n\n    return initializationPromise\n      .catch((error) => {\n        console.error('Error opening database: %o', error);\n        throw error;\n      });\n  }\n\n  clear() {\n    return this[p.db].promise\n      .then((db) => {\n        db.close();\n\n        return new Promise((resolve, reject) => {\n          const req = indexedDB.deleteDatabase(DB_NAME);\n          req.onsuccess = resolve;\n          req.onerror = reject;\n          req.onblocked = reject;\n        });\n      })\n      .then(() => {\n        this[p.db] = new Defer();\n        this[p.initializationStarted] = false;\n      });\n  }\n\n  getServices() {\n    return this[p.getAll](DB_SERVICE_STORE);\n  }\n\n  getService(id) {\n    return this[p.getById](DB_SERVICE_STORE, id);\n  }\n\n  setService(data) {\n    return this[p.set](DB_SERVICE_STORE, data);\n  }\n\n  deleteService(data) {\n    return this[p.remove](DB_SERVICE_STORE, data.id);\n  }\n\n  clearServices() {\n    return this[p.clearDb](DB_SERVICE_STORE);\n  }\n\n  [p.upgradeSchema](evt) {\n    const db = evt.target.result;\n    const fromVersion = evt.oldVersion;\n    if (fromVersion < 1) {\n      const store = db.createObjectStore(DB_SERVICE_STORE, { keyPath: 'id' });\n      store.createIndex('id', 'id', { unique: true });\n    }\n  }\n\n  [p.getAll](store) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readonly');\n          const results = [];\n          txn.onerror = reject;\n          txn.oncomplete = () => resolve(results);\n          txn.objectStore(store).openCursor().onsuccess = (evt) => {\n            const cursor = evt.target.result;\n            if (cursor) {\n              results.push(cursor.value);\n              cursor.continue();\n            }\n          };\n        });\n      });\n  }\n\n  [p.getById](store, id) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readonly');\n          txn.onerror = reject;\n          txn.objectStore(store).get(id).onsuccess = (evt) => {\n            resolve(evt.target.result);\n          };\n        });\n      });\n  }\n\n  [p.set](store, data) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readwrite');\n          txn.oncomplete = resolve;\n          txn.onerror = reject;\n          try {\n            txn.objectStore(store).put(data);\n          } catch (error) {\n            console.error(`Error putting data in ${DB_NAME}:`, error);\n            resolve();\n          }\n        });\n      });\n  }\n\n  [p.remove](store, id) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readwrite');\n          txn.oncomplete = resolve;\n          txn.onerror = reject;\n          try {\n            txn.objectStore(store).delete(id);\n          } catch (error) {\n            console.error(`Error deleting data from ${DB_NAME}:`, error);\n            resolve();\n          }\n        });\n      });\n  }\n\n  [p.clearDb](store) {\n    return this[p.db].promise\n      .then((db) => {\n        return new Promise((resolve, reject) => {\n          const txn = db.transaction([store], 'readwrite');\n          txn.oncomplete = resolve;\n          txn.onerror = reject;\n          txn.objectStore(store).clear();\n        });\n      });\n  }\n}\n","'use strict';\n\nconst p = Object.freeze({\n  started: Symbol('started'),\n  nextTickHandle: Symbol('nextTickHandle'),\n\n  // Private methods.\n  scheduleTick: Symbol('scheduleTick'),\n  onTick: Symbol('onTick'),\n});\n\nexport default class SequentialTimer {\n  /**\n   * Creates new SequentialTimer instance.\n   * @param {number} interval Minimum interval between two consequent ticks.\n   */\n  constructor(interval) {\n    this.interval = interval;\n\n    this[p.started] = false;\n    this[p.nextTickHandle] = null;\n    this[p.onTick] = null;\n\n    Object.seal(this);\n  }\n\n  /**\n   * Indicates whether timer started or not.\n   *\n   * @return {boolean}\n   */\n  get started() {\n    return this[p.started];\n  }\n\n  /**\n   * Starts timer. If timer has already been started nothing happens.\n   * @param {function} onTick Function that will be called on every tick.\n   */\n  start(onTick) {\n    if (this[p.started]) {\n      console.warn('Timer has been already started.');\n      return;\n    }\n\n    if (typeof onTick !== 'function') {\n      throw new Error('onTick handler should be a valid function.');\n    }\n\n    this[p.started] = true;\n    this[p.onTick] = onTick;\n\n    this[p.scheduleTick]();\n  }\n\n  /**\n   * Stops timer. If timer has not been started yet nothing happens.\n   */\n  stop() {\n    if (!this[p.started]) {\n      console.warn('Timer has not been started yet.');\n      return;\n    }\n\n    this[p.started] = false;\n\n    clearTimeout(this[p.nextTickHandle]);\n    this[p.nextTickHandle] = null;\n    this[p.onTick] = null;\n  }\n\n  /**\n   * Schedules next tick.\n   *\n   * @private\n   */\n  [p.scheduleTick]() {\n    if (!this[p.started] || this[p.nextTickHandle]) {\n      return;\n    }\n\n    this[p.nextTickHandle] = setTimeout(() => {\n      // Use Promise constructor to handle all possible results e.g. promises,\n      // unexpected exceptions and any other non-promise values.\n      (new Promise((resolve) => resolve(this[p.onTick]())))\n        .catch((error) => {\n          console.error(\n            'onTick handler failed, scheduling next tick anyway: %o',\n            error\n          );\n        })\n        .then(() => {\n          this[p.nextTickHandle] = null;\n          this[p.scheduleTick]();\n        });\n    }, this.interval);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport SequentialTimer from './common/sequential-timer';\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  origin: Symbol('origin'),\n  online: Symbol('online'),\n  lastSeenOnline: Symbol('lastSeenOnline'),\n\n  pingTimer: Symbol('pingTimer'),\n\n  // Private methods.\n  ping: Symbol('ping'),\n});\n\nexport default class BoxLink extends EventDispatcher {\n  constructor(origin) {\n    super(['online']);\n\n    if (!origin) {\n      throw new Error('Origin should be valid non-empty string.');\n    }\n\n    this[p.ping] = this[p.ping].bind(this);\n\n    this[p.origin] = origin;\n    this[p.online] = false;\n    this[p.lastSeenOnline] = 0;\n    this[p.pingTimer] = new SequentialTimer(Number.POSITIVE_INFINITY);\n\n    Object.seal(this);\n  }\n\n  get origin() {\n    return this[p.origin];\n  }\n\n  get online() {\n    return this[p.online];\n  }\n\n  /**\n   * Marks current box link as online. Method is called by the consumer to\n   * indicate that box has been seen online by other means than ping itself.\n   */\n  seenOnline() {\n    this[p.online] = true;\n    this[p.lastSeenOnline] = Date.now();\n  }\n\n  /**\n   * Enables automatic box link ping using specified interval.\n   *\n   * @param {number} interval Minimum interval that should be kept between two\n   * consequent ping requests.\n   */\n  enableAutoPing(interval) {\n    if (typeof interval !== 'number' || interval < 0) {\n      throw new Error('Interval should valid positive number.');\n    }\n\n    this[p.pingTimer].interval = interval;\n    if (!this[p.pingTimer].started) {\n      this[p.pingTimer].start(this[p.ping]);\n    }\n  }\n\n  /**\n   * Disables automatic box link ping.\n   */\n  disableAutoPing() {\n    if (!this[p.pingTimer].started) {\n      return;\n    }\n\n    this[p.pingTimer].stop();\n  }\n\n  /**\n   * Pings box link. Ping will be made immediately. Return promise will be\n   * resolved into boolean that indicates whether box link online or not.\n   *\n   * @return {Promise<boolean>}\n   */\n  ping() {\n    return this[p.ping](true /* force ping */);\n  }\n\n  /**\n   * Performs HTTP 'GET' request link's \"ping\" endpoint. Returns 'true' if\n   * response was successful (any of 200-299 status codes) or 'false'\n   * otherwise.\n   *\n   * @param {boolean} force Indicates that we should perform ping request even\n   * if the box was pinged recently.\n   * @return {Promise<boolean>}\n   * @private\n   */\n  [p.ping](force) {\n    // If ping is not forced and box link was seen online recently, we don't\n    // have to ping it again.\n    const seenOnlineRecently = Date.now() - this[p.lastSeenOnline] <\n      this[p.pingTimer].interval;\n    if (!force && (seenOnlineRecently || document.hidden)) {\n      return Promise.resolve();\n    }\n\n    return fetch(`${this[p.origin]}/ping`, { cache: 'no-store' })\n      .then(\n        (res) => res.ok,\n        (error) => {\n          console.error('Error occurred while pinging box: %o', error);\n          return false;\n        })\n      .then((isOnline) => {\n        if (isOnline) {\n          this[p.lastSeenOnline] = Date.now();\n        }\n\n        if (this[p.online] === isOnline) {\n          return;\n        }\n\n        this[p.online] = isOnline;\n        this.emit('online', isOnline);\n\n        return isOnline;\n      });\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport BoxLink from './box-link';\n\nconst p = Object.freeze({\n  // Private properties.\n  settings: Symbol('settings'),\n\n  localLink: Symbol('localLink'),\n  tunnelLink: Symbol('tunnelLink'),\n  linkPingInterval: Symbol('linkPingInterval'),\n  online: Symbol('online'),\n\n  // Private methods.\n  fetch: Symbol('fetch'),\n  pingLinks: Symbol('pingLinks'),\n  updateLink: Symbol('updateLink'),\n  onLinkOnlineChange: Symbol('onLinkOnlineChange'),\n  onLinkOriginChange: Symbol('onLinkOriginChange'),\n});\n\nexport default class Network extends EventDispatcher {\n  constructor(settings) {\n    super(['online']);\n\n    this[p.settings] = settings;\n    // Local box link that allows to connect to the box via local connection.\n    this[p.localLink] = null;\n    // Tunnel box link that allows to connect to the box via tunnel connection.\n    this[p.tunnelLink] = null;\n    this[p.linkPingInterval] = null;\n    this[p.online] = false;\n\n    this[p.pingLinks] = this[p.pingLinks].bind(this);\n    this[p.onLinkOnlineChange] = this[p.onLinkOnlineChange].bind(this);\n    this[p.onLinkOriginChange] = this[p.onLinkOriginChange].bind(this);\n\n    Object.seal(this);\n  }\n\n  /**\n   * Attach event listeners related to the connection status.\n   *\n   * @return {Promise}\n   */\n  init() {\n    window.addEventListener('online', this[p.pingLinks]);\n    window.addEventListener('offline', this[p.pingLinks]);\n\n    if ('connection' in navigator && 'onchange' in navigator.connection) {\n      navigator.connection.addEventListener('change', this[p.pingLinks]);\n\n      // We also ping the box every few minutes to make sure it's still there.\n      this[p.linkPingInterval] = this[p.settings].onlineCheckingLongInterval;\n    } else {\n      // If the Network Information API is not implemented, fallback to polling.\n      this[p.linkPingInterval] = this[p.settings].onlineCheckingInterval;\n    }\n\n    this[p.settings].on('local-origin', this[p.onLinkOriginChange]);\n    this[p.settings].on('tunnel-origin', this[p.onLinkOriginChange]);\n\n    this[p.onLinkOriginChange]();\n\n    return Promise.resolve();\n  }\n\n  get origin() {\n    if (this[p.localLink]) {\n      return this[p.localLink].origin;\n    } else if (this[p.tunnelLink]) {\n      return this[p.tunnelLink].origin;\n    }\n\n    throw new Error('Origin is not accessible');\n  }\n\n  get localOrigin() {\n    return this[p.settings].localOrigin;\n  }\n\n  get tunnelOrigin() {\n    return this[p.settings].tunnelOrigin;\n  }\n\n  get online() {\n    return this[p.online];\n  }\n\n  /**\n   * Request a JSON from a specified URL.\n   *\n   * @param {string} url The URL to send the request to.\n   * @param {string} method The HTTP method (defaults to \"GET\").\n   * @param {Object} body An object of key/value.\n   * @return {Promise}\n   */\n  fetchJSON(url, method = 'GET', body = undefined) {\n    return this[p.fetch](url, 'application/json', method, body)\n      .then((response) => response.json());\n  }\n\n  /**\n   * Request a Blob from a specified URL.\n   *\n   * @param {string} url The URL to send the request to.\n   * @param {string} blobType The Blob mime type (eg. image/jpeg).\n   * @param {string=} method The HTTP method (defaults to \"GET\").\n   * @param {Object=} body An object of key/value.\n   * @return {Promise<Blob>}\n   */\n  fetchBlob(url, blobType, method, body) {\n    return this[p.fetch](url, blobType, method, body)\n      .then((response) => response.blob());\n  }\n\n  /**\n   * Request a content of the specified type from a specified URL.\n   *\n   * @todo Detect if the URL is relative, if so prepend this.origin.\n   *\n   * @param {string} url The URL to send the request to.\n   * @param {string} accept The content mime type (eg. image/jpeg).\n   * @param {string=} method The HTTP method (defaults to \"GET\").\n   * @param {Object=} body An object of key/value.\n   * @return {Promise}\n   * @private\n   */\n  [p.fetch](url, accept, method = 'GET', body = undefined) {\n    method = method.toUpperCase();\n\n    const req = {\n      method,\n      headers: { Accept: accept },\n      cache: 'no-store',\n    };\n\n    if (method === 'POST' || method === 'PUT' || method === 'DELETE') {\n      req.headers['Content-Type'] = 'application/json;charset=UTF-8';\n    }\n\n    if (this[p.settings].session) {\n      // The user is logged in, we authenticate the request.\n      req.headers.Authorization = `Bearer ${this[p.settings].session}`;\n    }\n\n    if (body !== undefined) {\n      req.body = JSON.stringify(body);\n    }\n\n    return fetch(url, req)\n      .then((res) => {\n        if (!res.ok) {\n          throw new TypeError(\n            `The response returned a ${res.status} HTTP status code.`\n          );\n        }\n\n        // Let's check if request has been made to any of existing box links,\n        // in this case we can mark it as online eliminating redundant ping\n        // request.\n        const requestOrigin = (new URL(url)).origin;\n        if (this[p.localLink] && this[p.localLink].origin === requestOrigin) {\n          this[p.localLink].seenOnline();\n        } else if (this[p.tunnelLink] &&\n                   this[p.tunnelLink].origin === requestOrigin) {\n          this[p.tunnelLink].seenOnline();\n        }\n\n        return res;\n      })\n      .catch((error) => {\n        console.error('Error occurred while fetching content: ', error);\n        throw error;\n      });\n  }\n\n  /**\n   * Pings both local and tunnel box links simultaneously (if discovered).\n   *\n   * @private\n   */\n  [p.pingLinks]() {\n    if (this[p.localLink]) {\n      this[p.localLink].ping();\n    }\n\n    if (this[p.tunnelLink]) {\n      this[p.tunnelLink].ping();\n    }\n  }\n\n  /**\n   * Updates specified link. Link is updated if origin has changed, if origin\n   * became \"null\" link will be deleted.\n   *\n   * @param {Symbol} symbol Symbol associated either with local or tunnel link.\n   * @param {string?} origin Origin string, if \"null\" - origin is not available\n   * anymore.\n   * @private\n   */\n  [p.updateLink](symbol, origin) {\n    const link = this[symbol];\n\n    // Update is not required if we have neither origin nor link for it or if\n    // existing link's origin isn't changed.\n    if ((!origin && !link) || (link && link.origin === origin)) {\n      return;\n    }\n\n    // Let's destroy old link if origin is changed or not available anymore.\n    if (link) {\n      link.off('online', this[p.onLinkOnlineChange]);\n      link.disableAutoPing();\n      this[symbol] = null;\n    }\n\n    if (origin) {\n      this[symbol] = new BoxLink(origin);\n      this[symbol].enableAutoPing(this[p.linkPingInterval]);\n      this[symbol].on('online', this[p.onLinkOnlineChange]);\n      // Ping box link immediately once it's created to get \"online\" status as\n      // soon as possible.\n      this[symbol].ping();\n    }\n\n    // It doesn't matter whether link has been added or removed we should try to\n    // update \"online\" status.\n    this[p.onLinkOnlineChange]();\n  }\n\n  /**\n   * Updates box links whenever local or tunnel origin has changed.\n   *\n   * @private\n   */\n  [p.onLinkOriginChange]() {\n    this[p.updateLink](p.localLink, this.localOrigin);\n    this[p.updateLink](p.tunnelLink, this.tunnelOrigin);\n  }\n\n  /**\n   * Updates overall \"online\" status whenever either local or tunnel link\n   * \"online\" status has changed. If overall status has changed \"online\" event\n   * is emitted.\n   *\n   * @private\n   */\n  [p.onLinkOnlineChange]() {\n    const onlineStatus = !!this[p.localLink] && this[p.localLink].online ||\n      !!this[p.tunnelLink] && this[p.tunnelLink].online;\n\n    if (this[p.online] !== onlineStatus) {\n      this[p.online] = onlineStatus;\n      this.emit('online', onlineStatus);\n    }\n  }\n}\n","'use strict';\n\n// @todo Proxy recipes in the db and emit events on change (see services).\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  api: Symbol('api'),\n\n  // Recipe private properties.\n  service: Symbol('service'),\n});\n\nexport class Recipe {\n  constructor(service) {\n    if (!service) {\n      throw new Error('Service is required!');\n    }\n\n    this[p.service] = service;\n  }\n\n  get id() {\n    return this[p.service].id;\n  }\n\n  get label() {\n    return this[p.service].source && this[p.service].source.name;\n  }\n\n  get enabled() {\n    return this[p.service].status;\n  }\n}\n\nexport default class Recipes {\n  constructor(api) {\n    this[p.api] = api;\n\n    Object.seal(this);\n  }\n\n  /**\n   * Returns a promise resolving to a list of recipes.\n   *\n   * @return {Promise}\n   */\n  getAll() {\n    return this[p.api].post(\n      'services',\n      { channels: [{ feature: 'thinkerbell/rule-source' }] }\n    )\n    // Mark channels with more friendly names.\n    .then((services) => {\n      return services.map((service) => {\n        return Object.keys(service.channels).reduce((rule, channelId) => {\n          const channel = service.channels[channelId];\n\n          switch (channel.feature) {\n            case 'thinkerbell/is-rule-enabled':\n              rule.enabled = channelId;\n              break;\n            case 'thinkerbell/rule-source':\n              rule.getSource = channelId;\n              break;\n            case 'thinkerbell/remove-rule-id':\n              rule.remove = channelId;\n              break;\n          }\n\n          return rule;\n        }, {\n          id: service.id,\n          getSource: null,\n          enabled: null,\n          remove: null,\n          status: null,\n          source: null,\n        });\n      });\n    })\n    .then((services) => {\n      // Fetch recipe enabled statuses and sources.\n      const { enabledSelectors, sourceSelectors } = services.reduce(\n        (selectors, service) => {\n          selectors.enabledSelectors.push({ id: service.enabled });\n          selectors.sourceSelectors.push({ id: service.getSource });\n\n          return selectors;\n        },\n        { enabledSelectors: [], sourceSelectors: [] }\n      );\n\n      return Promise.all([\n        this[p.api].put('channels/get', enabledSelectors),\n        this[p.api].put('channels/get', sourceSelectors),\n      ])\n      .then(([statuses, sources]) => {\n        return services.map((service) => {\n          const statusResponse = statuses[service.enabled];\n          const sourceResponse = sources[service.getSource];\n\n          if (statusResponse && statusResponse.OnOff) {\n            service.status = statusResponse.OnOff === 'On';\n          } else {\n            console.error(\n              'Error occurred while retrieving recipe (%s) status: ',\n              service.id,\n              statusResponse && statusResponse.Error\n            );\n            service.status = false;\n          }\n\n          if (sourceResponse && sourceResponse.String) {\n            service.source = JSON.parse(sourceResponse.String);\n          } else {\n            console.error(\n              'Error occurred while retrieving recipe (%s) source: ',\n              service.id,\n              sourceResponse && sourceResponse.Error\n            );\n            service.source = null;\n          }\n\n          return new Recipe(service);\n        });\n      });\n    });\n  }\n\n  getGetters() {\n    // Currently we support only Clock, Motion Sensor and Door Lock as triggers.\n    const supportedFeatures = [\n      'clock/time-of-day-seconds',\n      'door/is-open',\n      'door/is-locked',\n    ];\n\n    return this[p.api].post(\n      'channels',\n      supportedFeatures.map((feature) => ({ feature, supports_fetch: true }))\n    )\n    .then((getters) => {\n      return getters.map((getter) => {\n        let name;\n        const options = [];\n\n        // Assign user friendly name to every getter and it's value options.\n        switch (getter.feature) {\n          case 'clock/time-of-day-seconds':\n            name = 'Everyday';\n            options.push(...[{\n              label: 'in the morning',\n              // 08:00 AM, 8 * 60 * 60 = 28800 seconds from 00:00.\n              value: { Geq: { Duration: 28800 } },\n            }, {\n              label: 'in the afternoon',\n              // 02:00 PM, 14 * 60 * 60 = 50400 seconds from 00:00.\n              value: { Geq: { Duration: 50400 } },\n            }, {\n              label: 'in the evening',\n              // 06:00 PM, 18 * 60 * 60 = 64800 seconds from 00:00.\n              value: { Geq: { Duration: 64800 } },\n            }]);\n            break;\n          case 'door/is-open':\n            name = 'Motion Sensor';\n            options.push({\n              label: 'detects motion',\n              value: { Eq: { OpenClosed: 'Open' } },\n            });\n            break;\n          case 'door/is-locked':\n            name = 'Door';\n            options.push({\n              label: 'is locked',\n              value: { Eq: { DoorLocked: 'Locked' } },\n            }, {\n              label: 'is unlocked',\n              value: { Eq: { DoorLocked: 'Unlocked' } },\n            });\n        }\n\n        return {\n          id: getter.id,\n          feature: getter.feature,\n          name: name || getter.adapter,\n          tags: getter.tags,\n          options,\n        };\n      });\n    });\n  }\n\n  getSetters() {\n    // Currently we support only TTS, camera, connected lights, motion sensor\n    // and door lock as actuators.\n    const supportedFeatures = [\n      'speak/sentence',\n      'camera/store-snapshot',\n      'light/is-on',\n      'door/is-locked',\n    ];\n\n    return this[p.api].post(\n      'channels',\n      supportedFeatures.map((feature) => ({ feature, supports_send: true }))\n    )\n    .then((setters) => {\n      return setters.map((setter) => {\n        const options = [];\n        let name;\n\n        switch (setter.feature) {\n          case 'speak/sentence':\n            name = 'say';\n            options.push(...[\n              {\n                label: '\"Good morning!\"',\n                value: { String: '\"Good morning!\"' },\n              },\n              {\n                label: '\"Good afternoon!\"',\n                value: { String: '\"Good afternoon!\"' },\n              },\n              {\n                label: '\"Good evening!\"',\n                value: { String: '\"Good evening!\"' },\n              },\n            ]);\n            break;\n          case 'camera/store-snapshot':\n            name = 'camera';\n            options.push(...[\n              {\n                label: 'takes a picture',\n                value: { 'Unit': null },\n              },\n              {\n                label: 'sends me a picture',\n                value: [\n                  {\n                    // Take a picture.\n                    destination: [{id: setter.id}],\n                    feature: 'camera/store-snapshot',\n                    value: { Unit: null },\n                  },\n                  {\n                    // Notify the user.\n                    destination: [{ feature: 'webpush/notify-msg' }],\n                    feature: 'webpush/notify-msg',\n                    value: {\n                      WebPushNotify: {\n                        message: JSON.stringify({\n                          message: 'Your bedroom patio door has just been ' +\n                          'opened. Here is a picture of what I see.',\n                          action: `dev/camera-latest-image/${setter.service}`,\n                        }),\n                        resource: 'res1',\n                      },\n                    },\n                  },\n                ],\n              },\n            ]);\n            break;\n          case 'light/is-on':\n            name = 'light';\n            options.push(...[\n              {\n                label: 'gets turned on',\n                value: { OnOff: 'On' },\n              },\n              {\n                label: 'gets turned off',\n                value: { OnOff: 'Off' },\n              },\n            ]);\n            break;\n          case 'door/is-locked':\n            name = 'door lock';\n            options.push(...[\n              {\n                label: 'locks the door',\n                value: { DoorLocked: 'Locked' },\n              },\n              {\n                label: 'unlocks the door',\n                value: { DoorLocked: 'Unlocked' },\n              },\n            ]);\n            break;\n        }\n\n        return {\n          id: setter.id,\n          feature: setter.feature,\n          name: name || setter.adapter,\n          tags: setter.tags,\n          options,\n        };\n      });\n    });\n  }\n\n  /**\n   * Create a new recipe.\n   *\n   * @return {Promise}\n   */\n  add({ name, getter, getterValue, setter, setterValue }) {\n    let execute;\n\n    if (Array.isArray(setterValue.value)) {\n      execute = setterValue.value;\n    } else if (typeof setterValue.value === 'object') {\n      execute = [\n        {\n          destination: [{ id: setter.id }],\n          feature: setter.feature,\n          value: setterValue.value,\n        },\n      ];\n    } else {\n      console.error('Setter doesn\\'t have a supported format:',\n        JSON.stringify(setter));\n    }\n\n    const recipe = {\n      name,\n      rules: [\n        {\n          conditions: [\n            {\n              source: [{ id: getter.id }],\n              feature: getter.feature,\n              range: getterValue.value,\n            },\n          ],\n          execute,\n        },\n      ],\n    };\n\n    return this[p.api].put(\n      'channels/set',\n      {\n        select: {\n          feature: 'thinkerbell/add-rule',\n        },\n        value: {\n          ThinkerbellRule: {\n            name,\n            source: JSON.stringify(recipe),\n          },\n        },\n      }\n    );\n  }\n\n  /**\n   * Remove a recipe with the associated id.\n   *\n   * @param {Recipe} recipe Recipe instance to remove.\n   * @return {Promise}\n   */\n  remove(recipe) {\n    return this[p.api].put(\n      'channels/set',\n      {\n        select: { id: recipe[p.service].remove },\n        value: null,\n      }\n    );\n  }\n\n  /**\n   * Enable or disable the specified recipe.\n   *\n   * @param {Recipe} recipe Recipe to toggle status for.\n   * @param {boolean=} value Whether to enable or disable. Enable by default.\n   * @return {Promise}\n   */\n  toggle(recipe, value = true) {\n    const textValue = value ? 'On' : 'Off';\n    return this[p.api].put(\n      'channels/set',\n      {\n        select: { id: recipe[p.service].enabled },\n        value: { OnOff: textValue },\n      }\n    )\n    .then(() => {\n      recipe[p.service].status = value;\n    });\n  }\n\n  // Hack for the demo.\n  /**\n   * Create the following static recipe:\n   * * When:\n   *    * The first light is on\n   *    * It's 8:00am\n   * * Then:\n   *    * Turn all the lights off\n   *    * Notify the user\n   */\n  createDemoRecipes() {\n    Promise.all([\n        this.getGetters(),\n        this.getSetters(),\n      ])\n      .then(([getters, setters]) => {\n        const clockGetter = getters.find(\n          (getter) => getter.feature === 'clock/time-of-day-seconds'\n        );\n        // Commented until the Philips Hue adapter watcher lands in the box.\n        /*const firstLightGetter = getters.find(\n          (getter) => getter.feature === 'light/is-on'\n        );*/\n        const lightsSetter = setters.filter(\n          (setter) => setter.feature === 'light/is-on'\n        );\n\n        const conditions = [\n          // When it's 8:00am.\n          {\n            source: [{ id: clockGetter.id }],\n            feature: 'clock/time-of-day-seconds',\n            range: { Geq: { Duration: 28800 } },\n          },\n          // When the first light is on.\n          /*{\n            source: [{ id: firstLightGetter.id }],\n            feature: firstLightGetter.feature,\n            range: { Eq: { OnOff: 'On' } },\n          },*/\n        ];\n\n        const execute = [].concat(\n          // Turn off all lights.\n          lightsSetter.map((setter) => ({\n            destination: [{ id: setter.id }],\n            feature: setter.feature,\n            value: { OnOff: 'Off' },\n          })),\n          // Notify the user.\n          [\n            {\n              // Notify the user.\n              destination: [{ feature: 'webpush/notify-msg' }],\n              feature: 'webpush/notify-msg',\n              value: {\n                WebPushNotify: {\n                  message: JSON.stringify({\n                    message: 'Hello Alex, I\\'ve turned your kitchen lights ' +\n                    'off for you. Have a wonderful day!',\n                  }),\n                  resource: 'res1',\n                },\n              },\n            },\n          ]);\n\n        const recipe = {\n          name: 'Turn off the lights when I leave for work.',\n          rules: [\n            {\n              conditions,\n              execute,\n            },\n          ],\n        };\n\n        console.log('Recipe for the demo', recipe);\n\n        return this[p.api].put(\n          'channels/set',\n          {\n            select: {\n              feature: 'thinkerbell/add-rule',\n            },\n            value: {\n              ThinkerbellRule: {\n                name,\n                source: JSON.stringify(recipe),\n              },\n            },\n          }\n        );\n      });\n\n    this.createDoorLockDemoRecipe();\n  }\n\n  /**\n   * Create the following static recipe:\n   * * When:\n   *    * The door is open\n   *    * It's 8:00am\n   * * Then:\n   *    * Close the door\n   *    * Notify the user\n   */\n  createDoorLockDemoRecipe() {\n    Promise.all([\n      this.getGetters(),\n      this.getSetters(),\n    ])\n    .then(([getters, setters]) => {\n      const clockGetter = getters.find(\n        (getter) => getter.feature === 'clock/time-of-day-seconds'\n      );\n\n      const doorLockGetter = getters.find(\n        (getter) => getter.feature === 'door/is-locked'\n      );\n\n      const doorLockSetter = setters.find(\n        (setter) => setter.feature === 'door/is-locked'\n      );\n\n      const conditions = [\n        // When it's 8:00am.\n        {\n          source: [{ id: clockGetter.id }],\n          feature: 'clock/time-of-day-seconds',\n          range: { Geq: { Duration: 28800 } },\n        },\n        {\n          source: [{ id: doorLockGetter.id }],\n          feature: doorLockGetter.feature,\n          range: { Eq: { DoorLocked: 'Unlocked' } },\n        },\n      ];\n\n      const execute = [\n        {\n          destination: [{ id: doorLockSetter.id }],\n          feature: doorLockSetter.feature,\n          value: { DoorLocked: 'Locked' },\n        },\n        {\n          // Notify the user.\n          destination: [{ feature: 'webpush/notify-msg' }],\n          feature: 'webpush/notify-msg',\n          value: {\n            WebPushNotify: {\n              message: JSON.stringify({\n                message: 'Hello Alex, I\\'ve locked the door for you. ' +\n                  'Have a wonderful day!',\n              }),\n              resource: 'res1',\n            },\n          },\n        },\n      ];\n\n      const recipe = {\n        name: 'Lock the door when I leave for work.',\n        rules: [\n          {\n            conditions,\n            execute,\n          },\n        ],\n      };\n\n      return this[p.api].put(\n        'channels/set',\n        {\n          select: {\n            feature: 'thinkerbell/add-rule',\n          },\n          value: {\n            ThinkerbellRule: {\n              name,\n              source: JSON.stringify(recipe),\n            },\n          },\n        }\n      );\n    });\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\n\n// Private members\nconst p = Object.freeze({\n  // Properties,\n  api: Symbol('api'),\n  settings: Symbol('settings'),\n\n  // Methods:\n  listenForMessages: Symbol('listenForMessages'),\n});\n\nexport default class WebPush extends EventDispatcher {\n  constructor(api, settings) {\n    super(['message']);\n\n    this[p.api] = api;\n    this[p.settings] = settings;\n\n    Object.seal(this);\n  }\n\n  subscribeToNotifications(resubscribe = false) {\n    if (!navigator.serviceWorker) {\n      return Promise.reject('No service worker supported');\n    }\n\n    navigator.serviceWorker.addEventListener('message',\n      this[p.listenForMessages].bind(this));\n\n    const settings = this[p.settings];\n    if (settings.pushEndpoint && settings.pushPubKey && settings.pushAuth &&\n        !resubscribe) {\n      return Promise.resolve();\n    }\n\n    return navigator.serviceWorker.ready\n      .then((reg) => reg.pushManager.subscribe({ userVisibleOnly: true }))\n      .then((subscription) => {\n        const endpoint = subscription.endpoint;\n        const key = subscription.getKey ? subscription.getKey('p256dh') : '';\n        const auth = subscription.getKey ? subscription.getKey('auth') : '';\n        settings.pushEndpoint = endpoint;\n        settings.pushPubKey = btoa(String.fromCharCode.apply(null,\n          new Uint8Array(key)));\n        settings.pushAuth = btoa(String.fromCharCode.apply(null,\n          new Uint8Array(auth)));\n\n        // Send push information to the server.\n        // @todo We will need some library to write taxonomy messages.\n        const pushConfigurationMsg = [[\n            [{ id: 'setter:subscribe.webpush@link.mozilla.org' }],\n            {\n              Json: {\n                subscriptions: [{\n                  public_key: settings.pushPubKey,\n                  push_uri: settings.pushEndpoint,\n                  auth: settings.pushAuth,\n                }],\n              },\n            },\n          ]];\n\n        return this[p.api].put('channels/set', pushConfigurationMsg);\n      })\n      .then(() => {\n        // Setup some common push resources.\n        const pushResourcesMsg = [[\n          [{ id: 'setter:resource.webpush@link.mozilla.org' }],\n          { Json: { resources: ['res1'] } },\n        ]];\n\n        return this[p.api].put('channels/set', pushResourcesMsg);\n      })\n      .catch((error) => {\n        if (Notification.permission === 'denied') {\n          throw new Error('Permission request was denied.');\n        }\n\n        console.error('Error while saving subscription ', error);\n        throw new Error(`Subscription error: ${error}`);\n      });\n  }\n\n  [p.listenForMessages](evt) {\n    const msg = evt.data || {};\n\n    if (!msg.action) {\n      return;\n    }\n\n    this.emit('message', msg);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from '../common/event-dispatcher';\n\nconst TYPE = 'unknown';\n\nconst p = Object.freeze({\n  // Private properties.\n  api: Symbol('api'),\n\n  // Public getter only properties.\n  id: Symbol('id'),\n  manufacturer: Symbol('manufacturer'),\n  model: Symbol('model'),\n  name: Symbol('name'),\n  watchers: Symbol('watchers'),\n  tags: Symbol('tags'),\n  channels: Symbol('channels'),\n\n  // Private methods.\n  getChannels: Symbol('getChannel'),\n  getFetchChannel: Symbol('getFetchChannel'),\n  getSendChannel: Symbol('getSendChannel'),\n});\n\nexport default class BaseService extends EventDispatcher {\n  constructor(props, api, allowedEvents, watchers) {\n    super(allowedEvents);\n\n    // Private properties.\n    this[p.api] = api;\n\n    // Public getter only properties.\n    this[p.id] = props.id;\n    this[p.manufacturer] = props.properties && props.properties.manufacturer ||\n      '';\n    this[p.model] = props.properties && props.properties.model || '';\n    // Some service don't have name, but can have product_name instead.\n    this[p.name] = props.properties && props.properties.name ||\n      props.properties.product_name || '';\n    this[p.tags] = new Set(props.tags);\n    this[p.channels] = props.channels;\n    this[p.watchers] = watchers || new Map();\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  get id() {\n    return this[p.id];\n  }\n\n  get manufacturer() {\n    return this[p.manufacturer];\n  }\n\n  get model() {\n    return this[p.model];\n  }\n\n  get name() {\n    return this[p.name];\n  }\n\n  /**\n   * Sets a value via sending it to a service channel.\n   *\n   * @param {Object|string} selector Selector for the channel to use.\n   * @param {*} value Value to set.\n   * @return {Promise}\n   */\n  set(selector, value = null) {\n    const channel = this[p.getSendChannel](selector);\n    const accepts = channel.supports_send.accepts;\n\n    // If channel declares input value type, then we should use it, otherwise\n    // we send a \"null\" value.\n    const payload = [\n      { id: channel.id },\n      accepts ? { [accepts.requires || accepts.optional]: value } : null,\n    ];\n\n    return this[p.api].put('channels/set', [payload]);\n  }\n\n  /**\n   * Gets a value from a service channel.\n   *\n   * @param {Object} selector Selector for the channel to use.\n   * @return {Promise}\n   */\n  get(selector) {\n    const channel = this[p.getFetchChannel](selector);\n    const returns = channel.supports_fetch.returns;\n    const payload = { id: channel.id };\n\n    // If we expect binary data let's request it properly.\n    if (returns && (returns.requires || returns.optional) === 'Binary') {\n      return this[p.api].blob('channels/get', payload);\n    }\n\n    // We request getter value by unique getter id, so we can have only\n    // results for this getter.\n    return this[p.api].put('channels/get', payload)\n      .then((response) => response[channel.id]);\n  }\n\n  /**\n   * Setups value watcher for the getter matching specified selector.\n   *\n   * @param {string} alias Watcher alias to match getter which value we would\n   * like to watch.\n   * @param {function} handler Function to be called once getter value changes.\n   */\n  watch(alias, handler) {\n    const watcher = this[p.watchers].get(alias);\n    if (!watcher) {\n      throw new Error('Unsupported watcher `${alias}`!');\n    }\n\n    const [selector, processor, wrappedHandlers = new Map()] = watcher;\n    if (wrappedHandlers.size === 0) {\n      watcher.push(wrappedHandlers);\n    }\n\n    let wrappedHandler = wrappedHandlers.get(handler);\n    if (!wrappedHandler) {\n      wrappedHandler = (value) => handler(this[processor](value));\n      wrappedHandlers.set(handler, wrappedHandler);\n    }\n\n    const { id: getterId } = this[p.getFetchChannel](selector);\n    this[p.api].watch(getterId, wrappedHandler);\n  }\n\n  /**\n   * Removes value watcher for the getter matching specified selector.\n   *\n   * @param {string} alias Watcher alias to match getter for which we would like\n   * to remove value watcher.\n   * @param {function} handler Function that was used in corresponding watch\n   * call.\n   */\n  unwatch(alias, handler) {\n    const watcher = this[p.watchers].get(alias);\n    if (!watcher) {\n      throw new Error('Unsupported watcher `${alias}`!');\n    }\n\n    const [selector,, wrappedHandlers] = watcher;\n\n    const wrappedHandler = wrappedHandlers.get(handler);\n    wrappedHandlers.delete(handler);\n\n    const { id: getterId } = this[p.getFetchChannel](selector);\n    this[p.api].unwatch(getterId, wrappedHandler);\n  }\n\n  /**\n   * Returns list of service tags.\n   *\n   * @return {Array<string>}\n   */\n  getTags() {\n    // Return a copy of the set in the form of plain array, to avoid side\n    // modifications.\n    return Array.from(this[p.tags]);\n  }\n\n  /**\n   * Adds specified tag to the service/all its channels tag list.\n   *\n   * @param {string} tag Tag to add.\n   * @return {Promise}\n   */\n  addTag(tag) {\n    if (!tag || typeof tag !== 'string') {\n      throw new Error('Tag should be valid non-empty string.');\n    }\n\n    if (this[p.tags].has(tag)) {\n      return Promise.resolve();\n    }\n\n    this[p.tags].add(tag);\n\n    // For now we mark channels with the specified tag as well, so that tag can\n    // be picked up from the places that don't have access to the service\n    // instance (eg. recipes view).\n    const servicesSelector = { services: { id: this[p.id] }, tags: tag };\n    const channelsSelector = { channels: { service: this[p.id] }, tags: tag };\n\n    return Promise.all([\n      this[p.api].post('services/tags', servicesSelector),\n      this[p.api].post('channels/tags', channelsSelector),\n    ])\n    .catch((error) => {\n      this[p.tags].delete(tag);\n      throw error;\n    });\n  }\n\n  /**\n   * Removes specified tag from the service/all its channels tag list.\n   *\n   * @param {string} tag Tag to remove.\n   * @return {Promise}\n   */\n  removeTag(tag) {\n    if (!tag || typeof tag !== 'string') {\n      throw new Error('Tag should be valid non-empty string.');\n    }\n\n    if (!this[p.tags].has(tag)) {\n      return Promise.resolve();\n    }\n\n    this[p.tags].delete(tag);\n\n    const servicesSelector = { services: { id: this[p.id] }, tags: tag };\n    const channelsSelector = { channels: { service: this[p.id] }, tags: tag };\n\n    return Promise.all([\n      this[p.api].delete('services/tags', servicesSelector),\n      this[p.api].delete('channels/tags', channelsSelector),\n    ])\n    .catch((error) => {\n      this[p.tags].add(tag);\n      throw error;\n    });\n  }\n\n  /**\n   * Method that should be called when service instance is not needed anymore.\n   * Classes that extend BaseService and override this method should always call\n   * super.teardown() method as well.\n   */\n  teardown() {\n    for (const watcher of this[p.watchers].values()) {\n      const [selector,, wrappedHandlers] = watcher;\n\n      // If nobody set up watchers or all watchers has been properly unwatched,\n      // we don't have anything to do here.\n      if (!wrappedHandlers || wrappedHandlers.size === 0) {\n        continue;\n      }\n\n      const { id: getterId } = this[p.getFetchChannel](selector);\n      for (const wrappedHandler of wrappedHandlers.values()) {\n        console.warn(`Forgotten watcher for ${getterId}!`);\n        this[p.api].unwatch(getterId, wrappedHandler);\n      }\n\n      wrappedHandlers.clear();\n    }\n  }\n\n  /**\n   * Returns list of channels that match to specified selector.\n   * @param {Object|string} selector Selector that channel should match to.\n   * @return {Array<Object>}\n   * @private\n   */\n  [p.getChannels](selector) {\n    if (selector.id) {\n      const channel = this[p.channels][selector.id];\n      return channel ? [channel] : [];\n    }\n\n    if (selector.feature || typeof selector === 'string') {\n      const channelFeature = selector.feature || selector;\n\n      return Object.keys(this[p.channels]).reduce((channels, key) => {\n        const channel = this[p.channels][key];\n\n        if (channel.feature === channelFeature) {\n          channels.push(channel);\n        }\n\n        return channels;\n      }, []);\n    }\n\n    return [];\n  }\n\n  /**\n   * Returns channel that supports fetch operation and matches to specified\n   * selector.\n   *\n   * @param {Object|string} selector Selector that channel should match to.\n   * @return {Object}\n   * @throws Will throw if there is no channel that corresponds to selector and\n   * supports fetch operation.\n   * @private\n   */\n  [p.getFetchChannel](selector) {\n    const channel = this[p.getChannels](selector).find(\n      (channel) => channel.supports_fetch\n    );\n\n    if (!channel) {\n      throw new Error(\n        `Couldn't find channel that supports \"fetch\" with selector: ${selector}`\n      );\n    }\n\n    return channel;\n  }\n\n  /**\n   * Returns channel that supports send operation and matches to specified\n   * selector.\n   *\n   * @param {Object|string} selector Selector that channel should match to.\n   * @return {Object}\n   * @throws Will throw if there is no channel that corresponds to selector and\n   * supports send operation.\n   * @private\n   */\n  [p.getSendChannel](selector) {\n    const channel = this[p.getChannels](selector).find(\n      (channel) => channel.supports_send\n    );\n\n    if (!channel) {\n      throw new Error(\n        `Couldn't find channel that supports \"send\" with selector: ${selector}`\n      );\n    }\n\n    return channel;\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'ip-camera';\n\nexport default class IpCameraService extends BaseService {\n  constructor(props, api) {\n    super(props, api);\n    Object.seal(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  getLatestImage() {\n    return this.get('camera/x-latest-image');\n  }\n\n  takeSnapshot() {\n    return this.set('camera/store-snapshot')\n      .then(() => this.get('camera/x-latest-image'));\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'light';\n\nexport default class LightService extends BaseService {\n  constructor(props, api) {\n    super(props, api);\n    Object.seal(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  isAvailable() {\n    return this.get('device/available')\n      .then((response) => response.OnOff === 'On');\n  }\n\n  isOn() {\n    return this.get('light/is-on')\n      .then((response) => response.OnOff === 'On');\n  }\n\n  /**\n   * Turn the bulb on or off.\n   *\n   * @param {boolean} on Whether to turn it on (true) or off (false).\n   * @return {Promise}\n   */\n  turn(on) {\n    return this.set('light/is-on', on ? 'On' : 'Off');\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'door-lock';\n\nexport default class DoorLockService extends BaseService {\n  constructor(props, api) {\n    super(props, api);\n    Object.seal(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  /**\n   * Checks if the lock is locked.\n   *\n   * @return {Promise.<boolean>}\n   */\n  isLocked() {\n    return this.get('door/is-locked')\n      .then((response) => {\n        if (!response) {\n          throw new Error('Door lock status is not available yet!');\n        }\n\n        return response.DoorLocked === 'Locked';\n      });\n  }\n\n  /**\n   * Either locks or unlocks the lock depending on the \"locked\" parameter.\n   *\n   * @param {boolean} locked Boolean value indicating whether we want lock or\n   * unlock the lock.\n   * @return {Promise}\n   */\n  lockUnlock(locked) {\n    return this.set('door/is-locked', locked ? 'Locked': 'Unlocked');\n  }\n}\n","'use strict';\n\nimport BaseService from './base';\n\nconst TYPE = 'motion-sensor';\n\nconst p = Object.freeze({\n  onMotionStateChanged: Symbol('onMotionStateChanged'),\n});\n\n/**\n * Converts motion state value to boolean. Considers unknown state (null) the\n * same as state when motion is not detected.\n *\n * @param {Object} motionState Motion state object.\n * @return {boolean}\n * @private\n */\nconst motionStateToBoolean = function(motionState) {\n  if (!motionState) {\n    return false;\n  }\n\n  return motionState.OpenClosed === 'Open';\n};\n\nexport default class MotionSensorService extends BaseService {\n  constructor(props, api) {\n    super(props, api, undefined, new Map([\n      ['motion', ['door/is-open', p.onMotionStateChanged]],\n    ]));\n\n    Object.freeze(this);\n  }\n\n  get type() {\n    return TYPE;\n  }\n\n  /**\n   * Returns motion sensor state.\n   *\n   * @return {Promise.<boolean>}\n   */\n  isMotionDetected() {\n    return this.get('door/is-open').then(motionStateToBoolean);\n  }\n\n  /**\n   * Function that is called whenever motion state changes. It is intended to\n   * convert raw getter value into simple boolean.\n   *\n   * @param {Object} motionState State that indicates whether motion detected\n   * or not.\n   * @return {boolean}\n   * @private\n   */\n  [p.onMotionStateChanged](motionState) {\n    return motionStateToBoolean(motionState);\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport SequentialTimer from './common/sequential-timer';\nimport BaseService from './services/base';\nimport IpCameraService from './services/ip-camera';\nimport LightService from './services/light';\nimport DoorLockService from './services/door-lock';\nimport MotionSensorService from './services/motion-sensor';\n\nconst p = Object.freeze({\n  api: Symbol('api'),\n  settings: Symbol('settings'),\n  db: Symbol('db'),\n  cache: Symbol('services'),\n  pollingTimer: Symbol('pollingTimer'),\n\n  // Private methods.\n  getServiceInstance: Symbol('getServiceInstance'),\n  hasChannelWithFeature: Symbol('hasChannelWithFeature'),\n  getCache: Symbol('getCache'),\n});\n\n/**\n * Compare 2 objects. Returns true if all properties of object A have the same\n * value in object B. Extraneous properties in object B are ignored.\n * Properties order is not important.\n *\n * @param {Object} objectA\n * @param {Object} objectB\n * @return {boolean}\n */\nconst isSimilar = (objectA, objectB) => {\n  const keysA = Object.keys(objectA);\n  const keysB = Object.keys(objectB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  return !keysA.some((keyA) => {\n    const valueA = objectA[keyA];\n    const valueB = objectB[keyA];\n\n    const typeA = typeof valueA;\n\n    if (typeA !== typeof valueB) {\n      return true;\n    }\n\n    if (typeA !== 'object' || valueA === null || valueB === null) {\n      return valueA !== valueB;\n    }\n\n    if (Array.isArray(valueA)) {\n      // We don't sort arrays here since changed order likely means that array\n      // has changed.\n      return valueA.length !== valueB.length ||\n        valueA.some((itemA, index) => itemA !== valueB[index]);\n    }\n\n    return !isSimilar(valueA, valueB);\n  });\n};\n\nexport default class Services extends EventDispatcher {\n  constructor(db, api, settings) {\n    super(['services-changed', 'service-changed']);\n\n    this[p.db] = db;\n    this[p.api] = api;\n    this[p.settings] = settings;\n\n    this[p.cache] = null;\n    this[p.pollingTimer] = new SequentialTimer(\n      this[p.settings].servicePollingInterval\n    );\n\n    Object.seal(this);\n  }\n\n  /**\n   * Retrieves the list of the services available. Relies on IndexedDB and\n   * in-memory cache.\n   *\n   * @return {Promise<Array<BaseService>>} A promise that resolves with an\n   * array of objects.\n   */\n  getAll() {\n    return this[p.getCache]().then((cache) => Array.from(cache.values()));\n  }\n\n  /**\n   * Gets service by id from in-memory cache.\n   * @todo If service doesn't exist in the DB, fetch it from the box.\n   *\n   * @param {string} id Id of the service we retrieve.\n   * @return {Promise<BaseService>}\n   */\n  get(id) {\n    return this[p.getCache]().then((cache) => cache.get(id));\n  }\n\n  /**\n   * Starts or stops polling.\n   *\n   * @param {boolean} pollingEnabled Flag that indicates whether polling should\n   * be started or stopped.\n   */\n  togglePolling(pollingEnabled) {\n    if (pollingEnabled === this[p.pollingTimer].started) {\n      return;\n    }\n\n    if (pollingEnabled) {\n      this[p.pollingTimer].start(this.sync.bind(this));\n    } else {\n      this[p.pollingTimer].stop();\n    }\n  }\n\n  /**\n   * Tries to sync local service list with the actual remote one and emits\n   * appropriate events.\n   *\n   * @return {Promise}\n   */\n  sync() {\n    return Promise.all([\n      this[p.api].get('services'),\n      this[p.db].getServices(),\n      this[p.getCache](),\n    ])\n    .then(([fetchedServices, storedServices, cache]) => {\n      let servicesToAddCount = 0;\n      fetchedServices.forEach((fetchedService) => {\n        const storedService = storedServices.find(\n          (storedService) => storedService.id === fetchedService.id\n        );\n\n        const isExistingService = !!storedService;\n\n        if (isExistingService && isSimilar(fetchedService, storedService)) {\n          return;\n        }\n\n        // Populate the db with the latest service.\n        this[p.db].setService(fetchedService);\n\n        const service = this[p.getServiceInstance](fetchedService);\n        cache.set(service.id, service);\n\n        if (isExistingService) {\n          this.emit('service-changed', service);\n        } else {\n          servicesToAddCount++;\n        }\n      });\n\n      const servicesToRemoveCount = storedServices.length +\n        servicesToAddCount - fetchedServices.length;\n      if (servicesToRemoveCount > 0) {\n        storedServices.forEach((storedService) => {\n          const fetchedService = fetchedServices.find(\n            (fetchedService) => fetchedService.id === storedService.id\n          );\n\n          if (!fetchedService) {\n            this[p.db].deleteService(storedService);\n\n            // We should teardown service instance and remove it from the cache.\n            const cachedService = cache.get(storedService.id);\n            cachedService.teardown();\n            cache.delete(cachedService.id);\n          }\n        });\n      }\n\n      if (servicesToAddCount > 0 || servicesToRemoveCount > 0) {\n        this.emit('services-changed');\n      }\n    });\n  }\n\n  /**\n   * Returns in-memory service cache. When cache is not initialized we fill it\n   * in with the content of local IndexedDB.\n   *\n   * @return {Promise<Map<string, BaseService>>}\n   * @private\n   */\n  [p.getCache]() {\n    if (this[p.cache]) {\n      return this[p.cache];\n    }\n\n    return this[p.cache] = this[p.db].getServices()\n      .catch((err) => {\n        console.error('Could not load services from the local DB: %o', err);\n        // Don't consider IndexedDB failure as critical error.\n        return [];\n      })\n      .then((dbServices) => {\n        const cache = new Map();\n\n        dbServices.forEach((dbService) => {\n          cache.set(dbService.id, this[p.getServiceInstance](dbService));\n        });\n\n        return cache;\n      });\n  }\n\n  /**\n   * Creates specific service instance using raw data returned from server. If\n   * there is no specific service class provided, BaseService class is used.\n   *\n   * @param {Object} data Service raw data.\n   * @return {Object}\n   * @private\n   */\n  [p.getServiceInstance](data) {\n    switch (data.adapter) {\n      case 'ip-camera@link.mozilla.org':\n        return new IpCameraService(data, this[p.api]);\n\n      case 'philips_hue@link.mozilla.org':\n        return new LightService(data, this[p.api]);\n\n      case 'OpenZwave Adapter':\n        if (this[p.hasChannelWithFeature](data.channels, 'door/is-locked')) {\n          return new DoorLockService(data, this[p.api]);\n        }\n\n        if (this[p.hasChannelWithFeature](data.channels, 'door/is-open')) {\n          return new MotionSensorService(data, this[p.api]);\n        }\n\n        return new BaseService(data, this[p.api]);\n\n      default:\n        return new BaseService(data, this[p.api]);\n    }\n  }\n\n  /**\n   * Detects if channel list contains channel with specified feature.\n   *\n   * @param {Array<Object>} channels List of the channels to look through.\n   * @param {string} feature Feature that channel we're looking for should have.\n   * @return {boolean}\n   * @private\n   */\n  [p.hasChannelWithFeature](channels, feature) {\n    return Object.keys(channels).some(\n      (key) => channels[key].feature === feature\n    );\n  }\n}\n","'use strict';\n\nimport EventDispatcher from './common/event-dispatcher';\nimport SequentialTimer from './common/sequential-timer';\n\nconst p = Object.freeze({\n  settings: Symbol('settings'),\n  net: Symbol('net'),\n\n  watchTimer: Symbol('watchTimer'),\n  watchEventBus: Symbol('watchEventBus'),\n  watchGetters: Symbol('watchGetters'),\n\n  // Private methods.\n  getURL: Symbol('getURL'),\n  onceOnline: Symbol('onceOnline'),\n  onceAuthenticated: Symbol('onceAuthenticated'),\n  onceDocumentVisible: Symbol('onceDocumentVisible'),\n  onceReady: Symbol('onceReady'),\n  fetchGetterValues: Symbol('fetchGetterValues'),\n  updateGetterValue: Symbol('updateGetterValue'),\n});\n\n/**\n * Instance of the API class is intended to abstract consumer from the API\n * specific details (e.g. API base URL and version). It also tracks\n * availability of the network, API host and whether correct user session is\n * established. If any of this conditions is not met all API requests are\n * blocked until it's possible to perform them, so consumer doesn't have to\n * care about these additional checks.\n */\nexport default class API {\n  constructor(net, settings) {\n    this[p.net] = net;\n    this[p.settings] = settings;\n\n    this[p.watchTimer] = new SequentialTimer(this[p.settings].watchInterval);\n    this[p.watchEventBus] = new EventDispatcher();\n    this[p.watchGetters] = new Map();\n\n    this[p.fetchGetterValues] = this[p.fetchGetterValues].bind(this);\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Performs HTTP 'GET' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @return {Promise}\n   */\n  get(path) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path)));\n  }\n\n  /**\n   * Performs HTTP 'POST' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'POST' body.\n   * @return {Promise}\n   */\n  post(path, body) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path), 'POST', body));\n  }\n\n  /**\n   * Performs HTTP 'PUT' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'PUT' body.\n   * @return {Promise}\n   */\n  put(path, body) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path), 'PUT', body));\n  }\n\n  /**\n   * Performs HTTP 'DELETE' API request and accepts JSON as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'DELETE' body.\n   * @return {Promise}\n   */\n  delete(path, body) {\n    return this[p.onceReady]()\n      .then(() => this[p.net].fetchJSON(this[p.getURL](path), 'DELETE', body));\n  }\n\n  /**\n   * Performs either HTTP 'GET' or 'PUT' (if body parameter is specified) API\n   * request and accepts Blob as response.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path.\n   * @param {Object=} body Optional object that will be serialized to JSON\n   * string and sent as 'PUT' body.\n   * @param {string=} accept Mime type of the Blob we expect as a response\n   * (default is image/jpeg).\n   * @return {Promise}\n   */\n  blob(path, body, accept = 'image/jpeg') {\n    return this[p.onceReady]()\n      .then(() => {\n        if (body) {\n          return this[p.net].fetchBlob(\n            this[p.getURL](path), accept, 'PUT', body\n          );\n        }\n\n        return this[p.net].fetchBlob(this[p.getURL](path), accept);\n      });\n  }\n\n  /**\n   * Registers watcher for the getter with specified id.\n   *\n   * @todo We may need to accept getter's \"supports_fetch\" property in the\n   * future too, to validate getter value type.\n   *\n   * @param {string} getterId Id of the getter we'd like to watch.\n   * @param {function} handler Handler to be executed once watched value is\n   * changed.\n   */\n  watch(getterId, handler) {\n    this[p.watchEventBus].on(getterId, handler);\n\n    if (this[p.watchGetters].has(getterId)) {\n      return;\n    }\n\n    this[p.watchGetters].set(getterId, {\n      id: getterId,\n      // Using null as initial value, some getters can return null when value\n      // is not yet available, so it perfectly fits our case.\n      value: null,\n    });\n\n    // We automatically start watching if at least one getter is requested to\n    // be watched.\n    if (!this[p.watchTimer].started) {\n      this[p.watchTimer].start(this[p.fetchGetterValues]);\n    }\n  }\n\n  /**\n   * Unregisters watcher for the getter with specified id.\n   *\n   * @param {string} getterId Id of the getter we'd like to not watch anymore.\n   * @param {function} handler Handler function that has been used with \"watch\"\n   * previously.\n   */\n  unwatch(getterId, handler) {\n    if (!this[p.watchGetters].has(getterId)) {\n      console.warn('Getter with id \"%s\" is not watched.', getterId);\n      return;\n    }\n\n    this[p.watchEventBus].off(getterId, handler);\n\n    // If there is no more listeners, we should not watch this getter anymore.\n    if (!this[p.watchEventBus].hasListeners(getterId)) {\n      this[p.watchGetters].delete(getterId);\n    }\n\n    // If no more getters are watched let's stop watching.\n    if (this[p.watchGetters].size === 0) {\n      this[p.watchTimer].stop();\n    }\n  }\n\n  /**\n   * Creates a fully qualified API URL based on predefined base origin, API\n   * version and specified resource path.\n   *\n   * @param {string} path Specific API resource path to be used in conjunction\n   * with the base API path and version.\n   * @return {string}\n   * @private\n   */\n  [p.getURL](path) {\n    if (!path || typeof path !== 'string') {\n      throw new Error('Path should be valid non-empty string.');\n    }\n\n    return `${this[p.net].origin}/api/v${this[p.settings].apiVersion}/${path}`;\n  }\n\n  /**\n   * Returns promise that is resolved once API is ready to use (API host is\n   * discovered and online, authenticated user session is established and\n   * document is visible).\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceReady]() {\n    return Promise.all([\n      this[p.onceOnline](),\n      this[p.onceAuthenticated](),\n      this[p.onceDocumentVisible](),\n    ]);\n  }\n\n  /**\n   * Returns promise that is resolved once API host is discovered and online.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceOnline]() {\n    const net = this[p.net];\n    if (net.online) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => net.once('online', () => resolve()));\n  }\n\n  /**\n   * Returns promise that is resolved once authenticated user session is\n   * established.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceAuthenticated]() {\n    const settings = this[p.settings];\n    if (settings.session) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => settings.once('session', () => resolve()));\n  }\n\n  /**\n   * Returns promise that is resolved once document becomes visible.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  [p.onceDocumentVisible]() {\n    if (!document.hidden) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      document.addEventListener('visibilitychange',\n      function onVisibilityChange() {\n        if (!document.hidden) {\n          document.removeEventListener('visibilitychange', onVisibilityChange);\n          resolve();\n        }\n      });\n    });\n  }\n\n  /**\n   * Fetches values for the set of getters.\n   *\n   * @return {Promise}\n   * @private\n   */\n  [p.fetchGetterValues]() {\n    // It may happen that all watchers have been unregistered in the meantime,\n    // so let's return early in this case.\n    if (this[p.watchGetters].size === 0) {\n      return Promise.resolve();\n    }\n\n    const selectors = Array.from(this[p.watchGetters].values()).map(\n      ({ id }) => ({ id })\n    );\n\n    return this.put('channels/get', selectors)\n      .then((response) => {\n        Object.keys(response).forEach((key) => {\n          const getter = this[p.watchGetters].get(key);\n          if (!getter) {\n            return;\n          }\n\n          this[p.updateGetterValue](getter, response[key]);\n        });\n      });\n  }\n\n  /**\n   * Updates getter value if needed. If value has changed, appropriate event is\n   * fired.\n   *\n   * @param {{ id: string, value: Object }} getter Getter to update value for.\n   * @param {Object} getterValue Getter value returned from the server.\n   *\n   * @private\n   */\n  [p.updateGetterValue](getter, getterValue) {\n    let valueChanged = false;\n\n    if (!getterValue || !getter.value) {\n      valueChanged = getterValue !== getter.value;\n    } else {\n      const [valueType] = Object.keys(getterValue);\n      if (valueType === 'Error') {\n        console.error(\n          'Failed to retrieve value for getter (%s): %o',\n          getter.id,\n          getterValue[valueType]\n        );\n\n        return;\n      }\n\n      const newValue = getterValue[valueType];\n      const oldValue = getter.value[valueType];\n\n      if (newValue && oldValue && typeof newValue === 'object') {\n        // @todo If value is a non-null object, we use their JSON representation\n        // to compare values. It's not performant and not reliable at all, but\n        // this OK until we have such values, once we support them we should\n        // have dedicated utility function for deep comparing objects.\n        valueChanged = JSON.stringify(newValue) !== JSON.stringify(oldValue);\n      } else {\n        valueChanged = newValue !== oldValue;\n      }\n    }\n\n    if (valueChanged) {\n      getter.value = Object.freeze(getterValue);\n      this[p.watchEventBus].emit(getter.id, getter.value);\n    }\n  }\n}\n","/* global URLSearchParams */\n\n'use strict';\n\nimport { Service } from 'components/mvc';\n\nimport Settings from './settings';\nimport Db from './db';\nimport Network from './network';\nimport Recipes from './recipes';\nimport WebPush from './webpush';\nimport Services from './services';\nimport API from './api';\n\n// Private members.\nconst p = Object.freeze({\n  // Private properties.\n  settings: Symbol('settings'),\n  db: Symbol('db'),\n  net: Symbol('net'),\n  boxes: Symbol('boxes'),\n  webPush: Symbol('webPush'),\n  api: Symbol('api'),\n});\n\nexport default class Foxbox extends Service {\n  constructor({ settings, db, net } = {}) {\n    super();\n\n    // Private properties.\n    this[p.settings] = settings || new Settings();\n    this[p.db] = db || new Db();\n    this[p.net] = net || new Network(this[p.settings]);\n    this[p.boxes] = Object.freeze([]);\n    this[p.api] = new API(this[p.net], this[p.settings]);\n    this[p.webPush] = new WebPush(this[p.api], this[p.settings]);\n\n    this.services = new Services(this[p.db], this[p.api], this[p.settings]);\n    this.recipes = new Recipes(this[p.api]);\n\n    Object.seal(this);\n  }\n\n  init() {\n    window.foxbox = this;\n\n    this[p.net].on('online', (online) => {\n      this._dispatchEvent('online', online);\n    });\n\n    this[p.webPush].on('message', (msg) => {\n      this._dispatchEvent('push-message', msg);\n    });\n\n    // No need to block the UI on the discovery process.\n    // Once we discover a box we can connect to, we will start\n    // polling and triggering box-online events with a boolean\n    // indicating if we have access to box or not.\n    this._initDiscovery()\n      .then(() => this[p.net].init());\n\n    return this._initUserSession()\n      // The DB is only initialised if there's no redirection to the box.\n      .then(() => this[p.db].init());\n  }\n\n  /**\n   * Clear all data/settings stored on the browser. Use with caution.\n   *\n   * @param {boolean} ignoreServiceWorker\n   * @return {Promise}\n   */\n  clear(ignoreServiceWorker) {\n    const promises = [this[p.settings].clear(), this[p.db].clear()];\n    if (!navigator.serviceWorker) {\n      return Promise.all(promises);\n    }\n\n    if (!ignoreServiceWorker) {\n      promises.push(navigator.serviceWorker.ready\n        .then((registration) => registration.unregister()));\n    }\n\n    return Promise.all(promises);\n  }\n\n  get online() {\n    return this[p.net].online;\n  }\n\n  get client() {\n    return this[p.settings].client;\n  }\n\n  get boxes() {\n    return this[p.boxes];\n  }\n\n  /**\n   * Get the URL of the box using the registration server.\n   * If it fails, we fallback to the previously set hostname.\n   * It there isn't, we schedule a retry.\n   *\n   * @return {Promise}\n   * @private\n   */\n  _initDiscovery() {\n    // For development purposes if you want to skip the\n    // discovery phase set the 'foxbox-skipDiscovery' variable to\n    // 'true'.\n    if (this[p.settings].skipDiscovery) {\n      return Promise.resolve();\n    }\n\n    return this[p.net].fetchJSON(this[p.settings].registrationService)\n      .then((boxes) => {\n        if (!Array.isArray(boxes)) {\n          console.warn('Got unexpected response from registry server', boxes);\n          return;\n        }\n\n        // We filter out boxes registered more than 2 minutes ago.\n        const now = Math.floor(Date.now() / 1000) - 60 * 2;\n        this[p.boxes] = Object.freeze(\n          boxes\n            .filter((box) => box.timestamp - now >= 0)\n            .map((box) => {\n              // NOTE(sgiles): There is consideration to allow\n              // only \"local_origin\" and \"tunnel_origin\", removing the\n              // need to parse message - this merges the relevant message\n              // fields into the main object\n              const { local_origin, tunnel_origin } = JSON.parse(box.message);\n              const client = box.client;\n\n              return Object.freeze({ local_origin, tunnel_origin, client });\n            })\n        );\n\n        // Fire event every time registration server returns a valid response.\n        // @todo We should improve this logic and check if boxes list has\n        // actually changed and if so only then override internal box list and\n        // fire event.\n        this._dispatchEvent('discovery');\n\n        // If the registration server didn't give us any info and\n        // we have no record of previous registrations, we schedule\n        // a retry.\n        if (!this[p.boxes].length &&\n            !this[p.settings].localOrigin &&\n            !this[p.settings].tunnelOrigin) {\n          throw new Error('Registration service did not return any boxes.');\n        }\n\n        if (!this[p.settings].configured && this[p.boxes].length === 1) {\n          this.selectBox();\n        }\n      })\n      .catch((error) => {\n        if (this[p.settings].localOrigin || this[p.settings].tunnelOrigin) {\n          // Default to a previously stored box registration.\n          return;\n        }\n\n        // If there's no previously stored box registration, we schedule a\n        // retry.\n        console.warn('Retrying box discovery... Reason is %o', error);\n        return new Promise((resolve) => {\n          setTimeout(() => {\n            this._initDiscovery().then(resolve, resolve);\n          }, 1000);\n        });\n      });\n  }\n\n  /**\n   * Change the currently selected box.\n   *\n   * @param {number} index The index of the box in the boxes array.\n   */\n  selectBox(index = 0) {\n    if (!this[p.boxes].length) {\n      this[p.settings].configured = false;\n      console.error('No boxes found. Is this app online? Is the box online?');\n\n      return;\n    }\n\n    if (index >= this[p.boxes].length) {\n      this[p.settings].configured = false;\n      console.error('Index out of range.');\n\n      return;\n    }\n\n    const box = this[p.boxes][index];\n\n    this[p.settings].localOrigin = box.local_origin;\n    if (box.tunnel_origin) {\n      this[p.settings].tunnelOrigin = box.tunnel_origin;\n    } else {\n      this[p.settings].tunnelOrigin = '';\n    }\n\n    this[p.settings].client = box.client;\n    this[p.settings].configured = true;\n  }\n\n  /**\n   * Detect a session token in the URL and process it if present.\n   *\n   * @return {Promise}\n   * @private\n   */\n  _initUserSession() {\n    if (this.isLoggedIn) {\n      return Promise.resolve();\n    }\n\n    const url = new URL(location.href);\n    const searchParams = new URLSearchParams(url.search.substring(1));\n    if (!searchParams.has('session_token')) {\n      return Promise.resolve();\n    }\n\n    // There is a session token in the URL, let's remember it.\n    // @todo Find a better way to handle URL escape.\n    this[p.settings].session = searchParams.get('session_token')\n      .replace(/ /g, '+');\n\n    // Remove the session param from the current location.\n    searchParams.delete('session_token');\n    url.search = searchParams;\n    location.replace(url.href);\n\n    // Returning rejected promise here the promise chain.\n    return Promise.reject();\n  }\n\n  get isLoggedIn() {\n    return !!this[p.settings].session;\n  }\n\n  /**\n   * Redirect the user to the box to get authenticated if she isn't already.\n   */\n  login() {\n    if (this.isLoggedIn) {\n      return;\n    }\n\n    const redirectUrl = encodeURIComponent(location);\n    location.replace(`${this[p.net].origin}/?redirect_url=${redirectUrl}`);\n  }\n\n  /**\n   * Log out the user.\n   */\n  logout() {\n    this[p.settings].session = null;\n  }\n\n  /**\n   * Ask the user for accepting push notifications from the box.\n   * This method will be call each time that we log in, but will\n   * stop the execution if we already have the push subscription\n   * information.\n   *\n   * @param {boolean} resubscribe Parameter used for testing\n   * purposes, and follow the whole subscription process even if\n   * we have push subscription information.\n   * @return {Promise}\n   */\n  subscribeToNotifications(resubscribe = false) {\n    return this[p.webPush].subscribeToNotifications(resubscribe);\n  }\n}\n","import { RoutingController } from 'components/mvc';\n\nimport UsersController from './users';\nimport ServicesController from './services';\nimport ServiceController from './service';\nimport ServiceTagsController from './service-tags';\nimport ThemesController from './themes';\nimport DevController from './dev';\n\nimport Foxbox from '../lib/foxbox/foxbox';\n\nexport default class MainController extends RoutingController {\n  constructor() {\n    const foxbox = new Foxbox();\n    const mountNode = document.querySelector('.app-view-container');\n    const options = { foxbox, mountNode };\n\n    const usersController = new UsersController(options);\n    const themesController = new ThemesController(options);\n\n    super({\n      '': usersController,\n      'users/(.+)': usersController,\n      'services': new ServicesController(options),\n      'services/(.+)/tags': new ServiceTagsController(options),\n      'services/(.+)': new ServiceController(options),\n      'themes': themesController,\n      'themes/(.+)': themesController,\n      'dev/(.+)/(.+)': new DevController(options),\n    });\n\n    this.foxbox = foxbox;\n  }\n\n  main() {\n    this.foxbox.init()\n      .then(() => {\n        if (this.foxbox.isLoggedIn) {\n          this.foxbox.subscribeToNotifications();\n\n          // Let's schedule service list sync as soon as possible.\n          this.foxbox.services.sync();\n\n          if (location.hash === '') {\n            location.hash = '#services';\n          }\n\n          this.foxbox.addEventListener('push-message', (msg) => {\n            if (msg.action) {\n              location.hash = msg.action;\n            }\n          });\n        } else {\n          location.hash = '#users/login';\n        }\n\n        this.route();\n      });\n  }\n}\n","import MainController from './controllers/main';\n\nconst mainController = new MainController();\nmainController.main();\n"],"names":["jsx","REACT_ELEMENT_TYPE","Symbol","type","props","key","children","defaultProps","childrenLength","arguments","length","propName","childArray","Array","i","$$typeof","undefined","ref","_owner","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","target","descriptor","enumerable","configurable","writable","Object","defineProperty","protoProps","staticProps","prototype","inherits","subClass","superClass","create","constructor","value","setPrototypeOf","__proto__","possibleConstructorReturn","self","call","ReferenceError","slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","iterator","next","done","push","err","isArray","NavigationMenu","_React$Component","foxbox","shouldComponentUpdate","handleOnClick","logout","render","route","location","hash","substr","split","shift","menuNodes","map","menu","className","id","label","this","bind","React","Component","BaseView","renderHeader","title","cssClass","renderFooter","renderBody","UserLogin","_BaseView","state","boxes","online","onBoxOnline","_this","onBoxDiscovery","onSelectChange","onFormSubmit","componentDidMount","addEventListener","componentWillUnmount","removeEventListener","evt","selectedBox","selectedIndex","setState","selectBox","preventDefault","login","loginEnabled","boxNodes","optionNodes","box","index","client","_this2","ALLOWED_ACTIONS","DEFAULT_ACTION","UsersController","main","action","includes","error","createElement","mountNode","Controller","ServicesListItem","service","onMotion","isAvailable","then","available","console","isOn","on","isMotionDetected","watch","isLocked","locked","unwatch","handleLightOnChange","checked","turn","onDoorLockUnlock","lockUnlock","motionDetected","getBulbColour","hue","sat","val","h","s","Math","round","l","renderLightService","isConnected","serviceType","icon","model","serviceName","getServiceName","serviceNameNode","background","renderDoorLock","renderMotionSensor","motionSensorNameNode","motionSensorClassName","renderGenericService","getTags","join","name","ServicesList","knownServices","services","filter","serviceNodes","Services","updateServiceList","updateServiceState","togglePolling","off","getAll","serviceId","findIndex","ServicesListView","ServicesController","CameraService","takeSnapshot","image","previousSnapshot","refs","snapshotPreview","src","newState","URL","createObjectURL","hasPreviousSnapshot","revokeObjectURL","cameraControlsClass","hasPreview","LightService","onServiceStateChanged","Service","get","CameraServiceView","LightServiceView","DefaultServiceView","propTypes","PropTypes","object","isRequired","string","ServiceController","TagList","tagNodes","tags","tag","onRemoveTag","ServiceTags","onAddTag","prompt","trim","addTag","removeTag","ServiceTagsController","ServiceTagsView","ThemesListItem","theme","enabled","handleOnChange","handleOnDelete","recipes","toggle","remove","update","Themes","themes","themeItems","ThemesListItemView","_this3","ThemesNew","updateServices","onGetterSelected","onGetterValueSelected","onSetterSelected","onSetterValueSelected","onSaveRecipe","all","getGetters","getSetters","getters","setters","selectedGetterIndex","Number","selectedGetterValueIndex","selectedSetterIndex","selectedSetterValueIndex","getter","getterValue","options","setter","setterValue","add","log","actionButtonClassName","headerClassName","renderGetterSelector","renderGetterValueSelector","renderSetterSelector","renderSetterValueSelector","getChannelName","option","_this4","channel","ThemesController","CameraLatestImage","getLatestImage","flexGrow","DevController","path","args","CameraLatestImageView","assertValidEventName","eventName","Error","assertValidHandler","handler","assertAllowedEventName","allowedEvents","indexOf","p","freeze","EventDispatcher","listeners","Map","handlers","Set","set","once","parameters","size","offAll","clear","emit","forEach","hasListeners","has","PREFIX","API_VERSION","QUERY_STRING_AUTH_TOKEN_NAME","UPPER_CASE_REGEX","settings","Settings","storage","localStorage","_EventDispatcher","values","keys","settingName","setting","settingStringValue","getItem","stringToSettingTypedValue","onStorage","seal","Promise","resolve","updateSetting","getDefaultSettingValue","newValue","currentValue","setItem","removeItem","replace","part","toLowerCase","stringValue","defaultValue","startsWith","substring","find","warn","CONFIGURED","LOCAL_ORIGIN","origin","TUNNEL_ORIGIN","CLIENT","String","SESSION","SKIP_DISCOVERY","SERVICE_POLLING_ENABLED","PUSH_ENDPOINT","PUSH_PUB_KEY","PUSH_AUTH","REGISTRATION_SERVICE","SERVICE_POLLING_INTERVAL","ONLINE_CHECKING_INTERVAL","ONLINE_CHECKING_LONG_INTERVAL","WATCH_INTERVAL","Defer","promise","reject","DB_NAME","DB_VERSION","DB_SERVICE_STORE","Db","db","initializationStarted","init","initializationPromise","req","indexedDB","open","onupgradeneeded","upgradeSchema","onsuccess","result","onerror","close","deleteDatabase","onblocked","getServices","getService","getById","setService","data","deleteService","clearServices","clearDb","fromVersion","oldVersion","store","createObjectStore","keyPath","createIndex","unique","txn","transaction","results","oncomplete","objectStore","openCursor","cursor","put","SequentialTimer","interval","started","nextTickHandle","onTick","start","scheduleTick","stop","setTimeout","BoxLink","ping","lastSeenOnline","pingTimer","POSITIVE_INFINITY","seenOnline","Date","now","enableAutoPing","disableAutoPing","force","seenOnlineRecently","document","hidden","fetch","cache","res","ok","isOnline","Network","localLink","tunnelLink","linkPingInterval","pingLinks","onLinkOnlineChange","onLinkOriginChange","navigator","connection","onlineCheckingLongInterval","onlineCheckingInterval","fetchJSON","url","method","body","response","json","fetchBlob","blobType","blob","accept","toUpperCase","Accept","headers","session","Authorization","JSON","stringify","status","requestOrigin","updateLink","symbol","link","localOrigin","tunnelOrigin","onlineStatus","Recipe","source","Recipes","api","post","channels","feature","reduce","rule","channelId","getSource","selectors","enabledSelectors","sourceSelectors","statuses","sources","statusResponse","sourceResponse","OnOff","parse","supportedFeatures","supports_fetch","Geq","Duration","Eq","OpenClosed","DoorLocked","adapter","supports_send","Unit","execute","recipe","textValue","createDemoRecipes","clockGetter","lightsSetter","conditions","concat","createDoorLockDemoRecipe","doorLockGetter","doorLockSetter","WebPush","subscribeToNotifications","resubscribe","serviceWorker","listenForMessages","pushEndpoint","pushPubKey","pushAuth","ready","reg","pushManager","subscribe","userVisibleOnly","subscription","endpoint","getKey","auth","btoa","fromCharCode","apply","Uint8Array","pushConfigurationMsg","pushResourcesMsg","Json","resources","Notification","permission","msg","TYPE","BaseService","watchers","manufacturer","properties","product_name","selector","getSendChannel","accepts","payload","requires","optional","getFetchChannel","returns","alias","watcher","processor","wrappedHandlers","wrappedHandler","getterId","from","servicesSelector","channelsSelector","teardown","getChannels","channelFeature","_this5","IpCameraService","_BaseService","DoorLockService","motionStateToBoolean","motionState","MotionSensorService","onMotionStateChanged","isSimilar","objectA","objectB","keysA","keysB","some","keyA","valueA","valueB","typeA","itemA","pollingTimer","servicePollingInterval","getCache","pollingEnabled","sync","fetchedServices","storedServices","servicesToAddCount","fetchedService","storedService","isExistingService","getServiceInstance","servicesToRemoveCount","cachedService","dbServices","dbService","hasChannelWithFeature","API","net","watchTimer","watchInterval","watchEventBus","watchGetters","fetchGetterValues","onceReady","getURL","apiVersion","onceOnline","onceAuthenticated","onceDocumentVisible","onVisibilityChange","_this6","updateGetterValue","valueChanged","valueType","oldValue","Foxbox","_Service","webPush","_dispatchEvent","_initDiscovery","_initUserSession","ignoreServiceWorker","promises","registration","unregister","skipDiscovery","registrationService","floor","timestamp","message","local_origin","tunnel_origin","configured","isLoggedIn","href","searchParams","URLSearchParams","search","redirectUrl","encodeURIComponent","MainController","querySelector","usersController","themesController","_RoutingController","RoutingController","mainController"],"mappings":"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","sourceRoot":"/source/"}